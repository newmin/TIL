## 1. 도메인 모델 시작

### 도메인

- `도메인` : 소프트웨어로 해결하고자 하는 문제 영역
- 하나의 도메인은 다시 하위 도메인으로 나눌 수 있다.
    - Ex) '온라인 서점' 도메인은 주문, 회원, 혜택, 카탈로그, 리뷰, 정산, 결제, 배송 등의 하위 도메인으로 나눌 수 있다.

### 도메인 모델

- `도메인 모델` : 특정 도메인을 개념적으로 표현한 것
    - 객체 기반으로 표현한 객체 모델 : 기능과 데이터를 함께 표현할 수 있다.
    - 상태 다이어그램을 활용한 상태 모델링

도메인 모델은 도메인 자체를 이해하기 위한 개념 모델이며, 이를 보고 바로 구현 코드를 작성할 수 있는 것은 아니다.  
따라서 구현 시에는 구현 기술에 맞는 별도의 구현 모델이 따로 필요하다.  
물론 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다. (객체 기반 모델 → 객체 지향 언어 사용)  

각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.  
도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 된다.  
즉, 모델의 각 구성요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다.  

### 도메인 모델 패턴

도메인 모델 패턴은 바로 전에서 이야기한 도메인 모델과 조금 다르게, 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 의미한다.  
애플리케이션의 아키텍처는 다음과 같다.  

- 사용자 인터페이스(UI), 표현(Presentation)
- 응용(Application)
- 도메인
- 인프라스트럭처(Infrastructure)

### 도메인 모델 도출

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 **핵심 구성요소, 규칙, 기능을 찾는 것**이다.  

### 엔티티와 밸류

도출한 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분할 수 있다.  

- 엔티티
    - 가장 큰 특징은 `식별자` 를 갖는다는 것이다.
        - 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다. (eq & hc 구현 시 식별자만 비교하도록 구현할 수 있다.)
        - 식별자는 다음 중 한 가지 방식으로 생성한다.
            - 특정 규칙에 따라 생성
            - UUID 사용
            - 값을 직접 입력
            - 일련번호 사용(시퀀스나 DB auto_increment 칼럼 사용)
- 밸류
    - 개념적으로 완전한 하나를 표현할 때 사용한다.
    - 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다. `불변`
        - 불변 객체는 참조 투명성과 스레드 안전한 특징을 갖고 있다.
    - 두 밸류 객체가 같은지 비교할 때는 모든 속성을 비교해야 한다.

도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 setter를 열어두지 말고, 생성 시점에 생성자를 통해 필요한 것을 전달해 주어야 한다.  
생성자에서는 전달받은 데이터의 유효성을 생성 시점에 검사할 수 있다.  

### 도메인 용어

도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.  

## 2. 아키텍처 개요

### 네 개의 영역

아키텍처를 설계할 때 출현하는 전형적인 영역은 다음과 같다.  

- 표현
    - 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할
    - Spring MVC
    - 사용자는 사람일 수도 있고, 외부 시스템일 수도 있다.
- 응용
    - 시스템이 사용자에게 제공해야 할 기능을 구현
    - 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용
    - 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임
- 도메인
    - 도메인 모델을 구현
    - 도메인 모델은 도메인의 핵심 로직을 구현
- 인프라스트럭처
    - 논리적인 개념 보다는 실제 구현 기술에 대한 것들
    - 도메인, 응용, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고, 인프라스트럭처 영역에서 제공하는 기능들을 사용해서 필요한 기능을 개발한다.

### 계층 구조 아키텍처

계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.  
예를 들어, 표현은 응용에, 응용은 도메인에 의존하고, 반대로 인프라스트럭처 계층이 도메인에 의존하거나 하지는 않는다.  

하지만, 짚고 넘어가야 할 것이 있는데 바로 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 **종속**된다는 점이다.  
이는 두 가지 문제를 안고 있는데, `테스트가 어렵다` 는 것과 `기능 확장이 어렵다` 는 것이다.  
상위 계층에서 구체적인 구현 기술에 대한 의존을 하고 있으니 실제 테스트가 어려워지고, 구현 기술에 의존적인 만큼 그에 맞추어진 타입, 객체들을 fit하게 만들게 되어 기능 확장을 어렵게 한다.  

이를 해결하기 위해서는 `DIP`를 사용해야 한다.  

### DIP

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다.  
그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제가 발생한다.  
DIP는 이를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.  

상위 계층에서는 상위 계층에서 정의한 인터페이스만을 의존하도록 하고, 이 인터페이스를 하위 계층인 인프라스트럭처 계층에서 구현하도록 하는 것이다.  
이러면 위의 두 가지 문제도 쉽게 해결할 수 있다.  
테스트가 어려운 문제는 인터페이스를 구현한 테스트 대역을 사용해 해결할 수 있고, 구현 기술에 대한 의존이 없으니 쉽게 저수준 구현 객체를 갈아끼워서 기능 확장 및 변경에 대처할 수 있게 된다.  

DIP를 잘못 생각하면 인터페이스와 구현 클래스를 분리하는 정도로만 생각할 수 있다.  
그래서 인프라스트럭처 계층에서 정의한 인터페이스를 상위 계층에서 사용하도록 설계할 수 있는데, 이는 올바른 DIP의 형태가 아니다.  
DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위한 것이므로, **DIP 적용 시 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출**하도록 해야 한다.  

DIP를 적용하게 되면 인프라스트럭처 계층이 반대로 응용 계층과 도메인 계층을 의존하는 구조가 된다.  

### 도메인 영역의 주요 구성요소

- 엔티티와 밸류
    - DB 테이블의 엔티티와 도메인 모델 엔티티의 차이
        - 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 것
            - ex) 주문을 표현하는 엔티티 Order는 주문과 관련된 데이터 뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공
        - 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것
- 애그리거트
    - 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 각각의 엔티티와 밸류에만 집중하게 된다.
    - 도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 되는데, 이것이 바로 애그리거트이다.
        - AGGREGATE를 애그리게이트라고 표현하면 동사 발음에 해당하므로, 명사 발음인 애그리거트라고 표기한다.
    - 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다.
        - ex) 주문 애그리거트는 '주문', '배송지 정보', '주문자', '주문 목록', '총 결제 금액' 등의 하위 모델로 구성된다.
    - 애그리거트는 군집에 속한 객체들을 관리하는 `루트 엔티티`를 갖는다.
        - 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
        - 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고, 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티, 밸류 객체에 접근하게 된다. 이는 애그리거트 내부 구현을 숨겨 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
    - 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.
- 리포지터리
    - 도메인 객체를 지속적으로 사용하려면 물리적인 저장소에 도메인 객체를 보관해야 한다. 이를 위한 도메인 모델이 리포지터리이다.
    - 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
    - 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의하고, 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행하게 된다.
- 도메인 서비스
    - 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다.

### 인프라스트럭처 개요

DIP에서 언급한 것처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.  

하지만, 무조건 인프라스트럭처에 대한 의존을 없애는 것이 좋은 것은 아니다.  
예를 들어, 트랜잭션 처리를 위해서는 Spring에서 제공하는 `@Transactional` 을 사용하는 것이 편리하다.  
영속성 처리를 위해 JPA를 사용할 경우 `@Entity` 나 `@Table` 같은 JPA 전용 애노테이션을 도메인 모델 클래스에 사용하는 것이 XML 설정을 사용하는 것보다 편리하다.  

DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 현명하다.  

### 모듈 구성

패키지 구성 규칙에 정답이 있는 것은 아니다.  

- UI, application, domain, infrastructure 영역별로 모듈이 위치할 패키지를 구성할 수 있다.
- 도메인이 크면 하위 도메인을 나누고 하위 도메인 마다 별도 패키지를 구성할 수 있다.
- domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.

## 3. 애그리거트

### 애그리거트

상위 모델에 대한 이해 없이 백 개 이상의 테이블을 한 장의 ERD에 모두 표시하고 도메인을 이해하려면 더 오랜 시간이 걸린다.  
도메인 객체 모델이 복잡해지면 개별 요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.  
상위 수준에서 모델이 어떻게 엮여 있는지 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 모델에 반영할 수 있는데 세부적인 모델만 이해한 상태로는 코드를 수정하기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 요구사항을 협의하게 된다.  
이는 장기적인 관점에서 코드를 더 수정하기 어렵게 만들기도 한다.  

복잡한 도메인을 이해하고 관리하기 쉬운 작은 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 `애그리거트` 이다.  

- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다.
- 애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 애그리거트는 경계를 갖는다.
    - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
    - 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
    - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 흔히 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽지만, 반드시 그렇지는 않다.
    - '상품'과 '리뷰'가 좋은 예다. Product 엔티티와 Review 엔티티는 하나의 페이지에서 같이 표시되지만, 함께 생성되지도 않고, 함께 변경되지도 않으며, 변경하는 주체가 각각 상품 담당자와 고객으로 다르다.

### 애그리거트 루트

애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다.  
도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.  
주문 애그리거트의 경우 주문 상세 금액을 변경하면 주문 객체의 총 주문 금액 합도 같이 변경되어야 한다.  

애그리거트에 속한 모든 객체가 일관성을 가지려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 `애그리거트 루트` 엔티티이다.  

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.  
이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.  

애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안 된다.  
외부에서 변경하더라도 올바른 변경을 위해 응용 계층에서 validation을 진행하고 변경하면 되지 않겠냐고 할 수도 있겠지만, 이렇게 되면 동일한 validation 로직이 곳곳에 퍼지게 된다.  
불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음 두 가지를 습관적으로 적용해야 한다.  

- setter를 public 하게 열지 않는다.
    - 공개 setter는 의미가 드러나는 메서드를 사용해서 구현할 가능성을 낮춘다.
- 밸류 타입은 불변으로 구현한다.
    - 밸류 객체가 불변이면 밸류 객체의 값을 변경하는 방법은 새로운 객체를 할당하는 것 뿐이다.
    - 밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.  
때로는 기능 실행 자체를 위임하기도 한다.  

### 트랜잭션 범위

트랜잭션 범위는 작을수록 좋다.  
한 개 테이블을 수정할 때에는 트랜잭션 충돌을 막기 위해 잠그는 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.  
잠금 대상이 더 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하고 이는 전체적인 성능을 떨어뜨린다.  

동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.  
이는 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 뜻한다.  
한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게 된다.  

만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.  

다음의 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.  

- 팀 표준
    - 팀과 조직의 표준에 따라 특정 기능을 하나의 트랜잭션으로 실행해야 하는 경우
    - DB가 다른 경우 글로벌 트랜잭션을 반드시 사용하도록 정할 수도 있다.
- 기술 제약
    - 도메인 이벤트와 비동기를 사용하여 위 경우를 해소할 수 있는데, 이런 이벤트 방식의 도입이 어려운 경우
- UI 구현의 편리
    - 운영자의 편리함을 위해 하나의 화면에서 여러 상태를 변경하고 싶은 경우

### 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.  

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.  
또한 동일하게 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.  
즉, 리포지터리는 적어도 다음의 두 메서드를 제공해야 한다.  

```java
repository.save(entity);
repository.findById(entityId);
```

### ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.  
애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트 루트를 참조한다는 것과 같다.  

```java
public class Order {
    private Member member;
}
```

필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.  
ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있고, 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터를 객체 탐색을 통해 조회할 수 있다.  
하지만, 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.  

- 편한 탐색 오용
    - 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있다.
- 성능 고민
    - JPA를 사용할 경우 지연 로딩과 즉시 로딩을 사용할 수 있는데, 단순 조회의 경우 즉시 로딩이 편리하지만 상태를 변경하는 기능을 사용할 경우 지연 로딩이 유리하다. 이런 경우의 수를 고려해서 연관 매핑과 로딩 전략을 결정해야 한다.
- 확장 어려움
    - 사용자가 늘고 트래픽이 증가하면 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.
    - 이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다.
    - 이는 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.

이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.  

```java
public class Order {
    private MemberId memberId;
}
```

ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.  
이는 모델의 복잡도를 낮추고, 애그리거트 간 의존을 제거하므로 응집도를 높여주는 효과도 있으며, 구현 복잡도도 낮춘다.  
참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 사용해 로딩하면 된다.  
이는 애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과를 만든다.  

다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽어야 할 때 조회 속도가 문제될 수 있다.  
조회 대상이 N개일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행한다 해서 이를 N+1 조회 문제라고 부른다.  
ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 전용 조회 쿼리를 사용하면 된다.  
JPQL 등으로 여러 애그리거트를 세타 조인해서 한 번의 쿼리로 로딩하도록 할 수 있다.  

애그리거트마다 서로 다른 저장소를 사용하는 경우에는 캐시를 적용하거나 조회 전용 저장소를 따로 구현할 수도 있다.  

### 애그리거트를 팩토리로 사용하기

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.  
필요한 데이터의 일부를 직접 제공하면서 동시에 중요한 도메인 로직을 함께 구현할 수 있게 된다.  

## 4. 리포지터리와 모델 구현 (JPA 중심)

### JPA를 이용한 리포지터리 구현

애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법이 다르긴 하다.  
보통 JPA를 많이 꼽는데, 데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM 만한 것이 없다.  
자바의 ORM 표준인 JPA를 이용해서 리포지터리와 애그리거트를 구현하는 방법에 대해 살펴보자.  

리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.  

리포지터리의 기본 기능은 다음의 두 가지이다.  

- ID로 애그리거트 조회하기
- 애그리거트 저장하기

인터페이스는 애그리거트 루트를 기준으로 작성한다.  

```java
@Repository
public class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Order findById(OrderNo id) {
        return entityManager.find(Order.class, id);
    }

    @Override
    public void save(Order order) {
        entityManager.persist(order);
    }
}
```

애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요는 없다.  
JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문이다.  

ID 외에 다른 조건으로 애그리거트를 조회할 때에는 JPA의 Criteria나 JPQL을 사용한다.  

### 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.  

- 애그리거트 루트는 엔티티이므로 `@Entity` 로 매핑한다.
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면,
    - 밸류는 `@Embeddable` 로 매핑한다.
    - 밸류 타입 프로퍼티는 `@Embedded` 로 매핑한다.

JPA의 `@Entity` 와 `@Embeddable` 로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.  
하이버네이트와 같은 JPA 프로바이더는 DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성한다.  
기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 되기 때문에, protected로 선언한다.  
(하이버네이트는 클래스를 상속한 프록시 객체를 이용해서 지연 로딩을 구현한다.  
이 경우 프록시 클래스에서 상위 클래스의 기본 생성자를 호출할 수 있어야 하므로 지연 로딩 대상이 되는 객체의 기본 생성자는 private이 아니라 protected로 지정해야 한다.  

밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때는 JPA 2.1의 AttributeConverter를 사용할 수 있다.  

```java
public interface AttributeConverter<X, Y> {
    Y convertToDatabaseColumn(X attribute);
    X convertToEntityAttribute(Y dbData);
}
```

실제 이를 구현한 Converter 클래스에서는 autoApply 속성값을 적용하여 모델에 출현하는 모든 X 타입의 프로퍼티에 대해 해당 컨버터를 적용할 수 있도록 한다.  

```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {
    // ...
}
```

애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.  
루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해봐야 한다.  
밸류가 아니라 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인해야 한다.  
특히, 자신만의 독자적인 라이프사이클을 갖는다면 다른 애그리거트일 가능성이 높다.  

애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 여부를 확인하는 것이다.  
하지만, 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안 된다.  
별도 테이블로 저장되고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 고유 식별자를 갖는 것은 아니다.  
게시글 데이터를 Article 테이블과 ArticleContent 테이블로 나눠서 저장한다고 하더라도, article_content 테이블에 있는 DB 식별자를 보고 ArticleContent도 식별자가 있을 것이라고 생각해서는 안 된다는 뜻이다.  
ArticleContent는 엔티티가 아니라 밸류로 생각하는 것이 맞다.  

밸류를 매핑한 테이블을 지정하기 위해 `@SecondaryTable` 과 `@AttributeOverride` 를 사용한다.  

```java
@Entity
@SecondaryTable(
    name = "article_content",
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "id")
)
public class Article {
    @Id
    private Long id;

    @AttributeOverrides({
        @AttributeOverride(name = "content",
            column = @Column(table = "article_content")),
        @AttributeOverride(name = "contentType",
            column = @Column(table = "article_content"))
    })
    private ArticleContent content;
}
```

앞서 3장에서 애그리거트 간 집합 연관은 성능상의 이유로 피해야 한다고 했다.  
그럼에도 불구하고 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있다.  

```java
@Entity
public class Product {
    @EmbeddedId
    private ProductId id;

    @ElementCollection
    @CollectionTable(name = "product_category",
            joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
}
```

### 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.  

조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면 되나, 이 방법이 항상 좋은 것은 아니다.  
특히 컬렉션에 대해 로딩 전략을 FetchType.EAGER로 설정하면 오히려 즉시 로딩 방식이 문제가 될 수 있다.  
Product에 EAGER 로딩으로 `List<Image>` 와 `List<Option>` 이 매핑된 예제에서, EntityManger.find() 메서드로 Product를 조회하면 하이버네이트는 3개의 테이블을 카타시안 조인한 쿼리를 날리게 된다.  
이는 쿼리 결과에 중복을 발생시키는데, 물론 하이버네이트가 중복된 데이터를 알맞게 제거해주긴 하지만 이는 애그리거트가 커지면 문제가 될 수 있다.  

애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.  
애그리거트가 완전해야 하는 2가지 이유는 다음과 같다.  

- 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 한다.
- 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.

두 번째 이유는 별도의 조회 전용 기능을 구현하는 방식을 사용하는 것이 유리할 때가 많기 때문에 애그리거트의 완전한 로딩과 관련된 문제는 상태 변경과 더 관련이 있다.  
JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 FetchType.LAZY로 놓고, 실제 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.  

### 애그리거트의 영속성 전파

애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다.  

애그리거트에 속한 `@Entity` 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 사이에 함께 처리되도록 설정해야 한다.  
`@OneToOne` , `@OneToMany` 는 cascade 속성의 기본값이 없으므로 cascade 속성값으로 CascadeType.PERSIST, CascadeType.REMOVE 를 설정한다.  

### 식별자 생성 기능

식별자 생성 규칙이 있는 경우 엔티티를 생성할 때 이미 생성한 식별자를 전달하므로 엔티티가 식별자 생성 기능을 제공하는 것보다는 별도 서비스로 식별자 생성 기능을 분리해야 한다.  
식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 한다.  

식별자 생성 규칙을 구현하기에 적합한 또 다른 장소는 리포지터리이다.  
리포지터리 인터페이스에 식별자를 생성하는 메서드를 추가하고 리포지터리 구현 클래스에서 알맞게 구현하면 된다.  

식별자 생성으로 DB의 자동 증가 칼럼을 사용할 경우 JPA의 식별자 매핑에서 `@GeneratedValue` 를 사용한다.  

## 5. 리포지터리의 조회 기능 (JPA 중심)

### 검색을 위한 스펙

리포지터리의 기본 기능 중 하나는 애그리거트를 찾는 것이다.  
그런데 검색 조건의 조합이 다양해지면 모든 조합별로 find 메서드를 정의할 수 없다.  
find 메서드가 너무 많아지기 때문이다.  

스펙(Specification)은 애그리거트가 특정 조건을 충족하는지 여부를 검사한다.  

```java
public interface Specification<T> {
    public boolean isSatisfiedBy(T agg);
}
```

스펙의 장점은 조합에 있다.  
두 스펙을 AND 연산자나 OR 연산자로 조합해서 새로운 스펙을 만들 수 있고, 이를 다시 조합해서 더 복잡한 스펙을 만들 수도 있다.  

### JPA를 위한 스펙 구현

하지만 위 방식에는 실행 속도 문제가 있다.  
애그리거트가 10만 개인 경우 10만 개 데이터를 DB에서 메모리로 로딩한 뒤에 다시 10만 개 객체를 루프 돌면서 스펙 검사를 하기 때문에, 시스템 성능을 과도하게 느리게 만들 것이다.  

실제 구현에서는 쿼리의 where절에 조건을 붙여서 필요한 데이터를 걸러야 한다.  
이는 스펙 구현도 메모리에서 걸러내는 방식에서 쿼리의 where를 사용하는 방식으로 바꿔야 한다는 것을 뜻한다.  
JPA는 다양한 검색 조건을 조합하기 위해 CriteriaBuilder와 Predicate를 사용하므로 JPA를 위한 스펙은 CriteriaBuilder와 Predicate를 이용해서 검색 조건을 구현해야 한다.  

### 조회 전용 기능 구현

다음 용도로 리포지터리를 사용하는 것은 적합하지 않다.  

- 여러 애그리거트를 조합해서 한 화면에 보여주는 데이터 제공
- 각종 통계 데이터 제공

위 기능을 애그리거트에서 제공하려고 시도하다 보면 JPA의 지연 로딩과 즉시 로딩 설정, 연관 매핑으로 골치가 아플 것이다.  
게다가 애그리거트 간에 직접 연관을 맺으면 ID 참조의 장점을 활용할 수 없게 된다.  
통계 데이터도 다양한 테이블을 조인하거나 DBMS 전용 기능을 사용해야 구할 수 있는데, 이는 JPQL이나 Criteria로 처리하기 힘들다.  

애초에 이런 기능은 조회 전용 쿼리로 처리해야 하는 것들이다.  
JPA와 하이버네이트를 사용하면 동적 인스턴스 생성, `@Subselect` 확장 기능, 네이티브 쿼리를 이용해서 조회 전용 기능을 구현할 수 있다.  

```sql
select new com.myshop.order.dto.OrderView(
    o.number.number, o.totalAmounts, m.id, m.name, p.name)
...
```

동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연/즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있다는 점이다.  

## 6. 응용 서비스와 표현 영역

### 표현 영역과 응용 영역

도메인 영역을 잘 설계하는 것이 가장 중요하지만, 도메인만 잘 만든다고 끝나는 것은 아니다.  
응용 영역과 표현 영역이 사용자와 도메인을 연결해주는 매개체 역할을 한다.  

표현 영역은 사용자의 요청을 해석한다.  
요청을 받는 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용해서 사용자가 어떤 기능을 실행하고 싶은지를 판단하고 해당 기능을 제공하는 응용 서비스를 실행시킨다.  

결국 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스이다.  
응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.  
사용자와의 상호작용은 표현 영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다.  

### 응용 서비스의 역할

응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현 영역 입장에서 보았을 때 응용 서비스는 도메인과의 연결을 제공하는 파사드(facade), 일종의 창구 역할을 한다.  

응용 서비스는 다음과 같은 역할을 가진다.  

- 도메인 객체 간의 실행 흐름을 제어
- 트랜잭션 처리
- 접근 제어
- 이벤트 처리

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 다음과 같은 문제가 발생한다.  
이런 문제들은 결과적으로 코드의 변경을 어렵게 만든다.  

- 첫 번째 문제는 코드의 응집성이 떨어진다는 것이다.
    - 도메인 로직이 서로 다른 곳에 나눠져서 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 뜻한다.
- 두 번째 문제는 여러 응용 서비스에서 중복된 도메인 로직을 구현할 가능성이 높아진다는 것이다.

### 응용 서비스의 구현

응용 서비스의 구현 자체는 크게 어렵지 않지만, 생각할 거리가 있다.  
그중 하나가 바로 응용 서비스의 크기이다.  

- 한 응용 서비스 클래스에 특정 도메인의 모든 기능 구현하기
    - 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.
    - 하나의 클래스가 거대해진다. 고로 연관성이 적은 코드가 한 클래스에 위치할 가능성이 높아진다.
    - 분리하는 것이 좋은 상황임에도 습관적으로 기존 클래스에 로직을 추가하게 된다.
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
    - 클래스 수는 많아지지만 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.
    - 여러 클래스에 동일한 중복 코드를 구현할 가능성이 있다.

또다른 논쟁거리는 인터페이스가 필요한지에 대한 여부이다.  
응용 서비스는 보통 런타임에 이를 교체하는 경우가 거의 없을 뿐만 아니라 한 응용 서비스의 구현체가 2개 이상인 경우도 매우 드물다.  
따라서 인터페이스가 명확히 필요한 상황이 아닌 이상, 무조건적으로 인터페이스를 작성하는 것이 좋은 설계는 아니다.  
표현 영역의 단위 테스트를 위해서 응용 서비스의 인터페이스를 추가해야 한다고 주장할 수도 있지만, Mockito와 같은 테스트 도구를 사용하면 실제 구현체 클래스에 대해서도 테스트 대역을 만들 수 있기 때문에 이 역시 인터페이스의 필요성에 대한 이유는 되지 못한다.  

다음으로 응용 서비스에서 표현 영역으로 애그리거트 자체를 리턴하는 문제다.  
코딩은 편할 수 있지만 이는 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.  
따라서 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행의 응집도를 높이는 확실한 방법이다.  

응용 서비스의 파라미터 타입을 결정할 때는 표현 영역과 관련된 타입을 사용하면 안 된다.  
예를 들어, 표현 영역에 해당하는 HttpServletRequest나 HttpSession을 응용 서비스의 파라미터로 전달하면 안 된다.  
응용 서비스에서 표현 영역에 대한 의존이 발생하면 다음과 같은 문제가 생길 수 있다.  

- 응용 서비스만 단독으로 테스트하기가 어려워진다.
- 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 하는 문제도 발생한다.
- 응용 서비스가 표현 영역의 역할을 대신하게 될 수도 있다.
    - 예를 들어 응용 서비스에서 HttpSession을 생성하고 세션에 인증과 관련된 정보를 담는 행위
    - 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워져, 결국 표현 영역의 응집도가 깨지게 된다.

트랜잭션은 프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다.  
프레임워크가 제공하는 규칙을 따르면 간단한 설정만으로 트랜잭션을 시작하고 커밋하고 예외가 발생하면 롤백할 수 있다.  

도메인 영역은 상태가 변경되면 이를 외부에 알리기 위해 이벤트를 발생시킬 수 있다.  

```java
public class Member {
    private Password password;

    public void initializePassword() {
        String new Password = generateRandomPassword();
        this.password = new Password(newPassword);
        Events.raise(new PasswordChangedEvent(this.id, password));
    }

    //...
}
```

도메인에서 이벤트를 발생시키면 그 이벤트를 받아서 처리할 코드가 필요한데, 그 역할을 하는 것이 바로 응용 서비스이다.  
응용 서비스는 이벤트를 받아서 이벤트에 알맞은 후처리를 할 수 있다.  

```java
public class InitPasswordService {
    
    @Transactional
    public void initializePassword(String memberId) {
        Events.handle((PasswordChangedEvent event) -> {
            // event.getId() 에 해당하는 기능 구현 (ex. 이메일 전송)
        });

        Member member = memberRepository.findById(memberId);
        checkMemberExists(member);
        member.initializePassword();
    }

}
```

이벤트를 사용하면 코드가 다소 복잡해지는 대신 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점을 얻을 수 있다.  
또한 시스템을 확장하는 데에 이벤트가 핵심 역할을 수행하게 된다.  

### 표현 영역

표현 영역의 책임은 다음과 같다.  

- 사용자가 시스템을 사용할 수 있도록 알맞은 흐름을 제공하는 것
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

### 값 검증

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.  
원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.  

그런데, 표현 영역은 잘못된 값이 존재하면 사용자에게 알려주고 값을 다시 입력받아야 한다.  
응용 서비스에서 값을 체크하고 예외를 발생하는 형태를 사용할 때의 문제점은 사용자에게 좋지 않은 경험을 제공한다는 것이다.  
동시에 여러 값이 잘못되었을 경우, 예외 발생 방식으로는 첫 번째 예외값밖에 검증할 수가 없다.  
이는 사용자가 같은 폼에 값을 여러 번 입력하게 만든다.  
이런 사용자 불편을 해소하려면 다음과 같이 응용 서비스에 값을 전달하기 전에 표현 영역에서 값을 검사하면 된다.  

표현 영역에서 필수 값과 형식을 검사하면 응용 서비스에서는 아이디 중복 여부와 같은 논리적 오류만 검사하면 된다.  
즉, 응용 서비스를 사용하는 표현 영역이 한 곳이라면 다음과 같은 역할 구조를 가져가는 것이 좋다.  

- 표현 영역은 필수 값, 값의 형식, 범위 등을 검증한다.
- 응용 서비스는 데이터의 존재 유무와 같은 논리적 오류를 검증한다.

만약 응용 서비스를 실행하는 주체가 다양하면 응용 서비스에서 반드시 파라미터로 전달받은 값이 올바른지 검사해야 한다.  

### 권한 검사

개발할 시스템마다 권한의 복잡도가 달라진다.  
단순한 시스템은 인증 여부만 검사하기도 하고, 복잡한 시스템은 관리자인지 여부에 따라 사용할 수 있는 기능이 달라지기도 한다.  
또, 실행할 수 있는 기능이 역할마다 달라지는 경우도 있다.  

보통 다음의 세 곳에서 권한 검사를 수행할 수 있다.  

- 표현 영역
- 응용 서비스
- 도메인

표현 영역에서 할 수 있는 가장 기본적인 검사는 인증된 사용자인지 아닌지 여부를 검사하는 것이다.  

- 어떤 URL을 처리하는 컨트롤러에 웹 요청을 전달하기 전에 인증 여부를 검사해서 인증된 사용자의 요청만 컨트롤러에 전달한다.
- 인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트 시킨다.

이런 접근 제어를 하기 좋은 위치가 서블릿 필터이다.  
서블릿 필터에서 사용자의 인증 정보를 생성하고 인증 여부를 검사하는 것이다.  

인증 여부뿐만 아니라 권한에 대해서 동일한 방식으로 필터를 사용해서 URL별 권한 검사를 할 수 있다.  
URL만으로 접근 제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 권한 검사를 수행할 수 있다.  
예를 들어 스프링의 AOP를 사용해서 다음과 같이 권한 검사를 할 수도 있다.  

```java
public class BlockMemberService {
    private MemberRepository memberRepository;

    @PreAuthorize("hasRole('ADMIN')")
    public void block(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
            throw new NoMemberException();
        }
        member.block();
    }
}
```

### 조회 전용 기능과 응용 서비스

서비스에서 수행하는 추가적인 로직 없이, 표현 영역에게 리포지토리의 조회 전용 메서드를 수행해서 바이패스만 하고 있다면 굳이 서비스를 만들 필요는 없다.  
이런 경우라면 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.  
응용 서비스가 항상 존재해야 한다는 강박관념을 가질 필요는 없다.
