# Sync / Async / Blocking / Non-Blocking
#TIL/concept

---

## 늘 헷갈리는 비동기 개념

안녕하세요! 이번 포스팅에서는 늘 모두가 ~~제가~~ 헷갈려하는 `Sync`와 `Async`, `Blocking`과 `Non-Blocking`에 대해 정리해 보려고 합니다.  
해당 개념들에 대해 개발자마다 의견도 조금씩 다르고, 이해하는 방식도 다를 수 있는데요.  
저도 제가 이해한 방식대로 간단하게 한번 정리해 보겠습니다.  

**어떤 작업을 요청하는 클라이언트를 A**, **작업을 수행해서 결과를 돌려주는 친구를 B**라고 전제하고 시작하겠습니다!  


### Sync VS. Async

동기와 비동기는 수행하는 작업의 주체성을 누가 가지고 있는지가 중요합니다.  

`동기(Sync)`는 **작업의 주체성을 A가 가지고** 있습니다.  
A가 B에게 작업을 요구하면, A는 B의 행위가 완전히 끝나거나, B가 결과를 돌려줄 때까지 기다렸다가 자신의 남은 일을 수행합니다.  
혹은 당장 결과를 받았더라도 해당 작업이 완료되지 않은 상태라면, B에게 지속적으로 물어보면서 작업 완료 여부를 조사합니다.  

즉, B가 언제 결과를 돌려주는지는 상관이 없지만, A 입장에서는 B의 작업 수행 완료 여부를 아는 것이 중요합니다.  

`비동기(Async)`는 **작업의 주체성을 B가 가지고** 있습니다.  
비동기 상황에서는 A가 B에게 작업을 요구하면서, 결과가 준비된다면 수행해달라고 요청하는 **콜백 함수**도 같이 넘깁니다.  
A는 B에게 작업을 요청한 후 요청한 작업에 대해서는 아무것도 신경쓰지 않고, 자신의 남은 일을 이어서 처리합니다.  

동기 상황에서는 해당 작업에 대한 완료 책임을 A가 가지고 있었다면, 비동기 상황에서는 요청을 받은 B가 오히려 해당 작업에 대한 책임을 가지고 있습니다.  
요청을 받은 B가 A에게서 받은 콜백 함수로 해당 작업을 처리하고 완료합니다.  


### Blocking VS. Non-Blocking

Blocking과 Non-Blocking은 로직의 흐름이 멈추는지, 멈추지 않는지를 생각해야 합니다.  

`Blocking`은 A가 B를 무작정 **기다리는 것**입니다.  
혹은 B가 A를 기다리게 한다라고도 볼 수 있겠네요.  

A는 작업을 요청한 후 B의 행위가 끝나기를 계속 기다립니다.  
만약 동기(Sync-Blocking) 상황이라면 B가 작업을 완료하고 결과를 돌려주기를 오매불망 기다릴 것이고, 비동기(Async-Blocking) 상황이라면 A가 넘겨준 콜백 함수를 B가 실행하고 완료하는 것을 기다릴 것입니다.  

그래서 Blocking 상황에서는 작업의 책임을 누가 가지고 있냐에 관계 없이 일단 A쪽에서 흘러가던 로직의 흐름이 멈춥니다.  

`Non-Blocking`은 B가 A에게 **일단 바로 손에 뭔가를 쥐여줍니다**.  
요청한 작업에 대한 결과가 요청과 동시에 준비되었다면 바로 결과를 쥐어줄 수도 있지만, 보통은 결과를 주기에 시간이 걸리기 때문에 아직 준비가 덜 됐다는 실패했다는 신호라도 쥐여줍니다.  
아니면 나중에 결과가 완성되면 여기에 꽂아줄게! 라고 하면서 빈 껍데기를 넘길 수도 있습니다.  

중요한 것은 A가 가던 길을 멈추지 않도록 한다는 것입니다.  
A는 진짜 결과든 가짜 결과든 일단 뭔가 받긴 바로 받았으니까, 자기가 해야할 나머지 일들을 계속 이어서 해 나갈 수 있습니다.  

A가 해당 작업의 완료 책임을 가지고 있다면(Sync-Non-Blocking), A는 주기적으로 B의 작업 완료 여부를 체크합니다.  
A가 작업의 주체성을 가지고 있기 때문에 B가 작업을 완료할 때까지 계속 핑퐁하면서 확인합니다.  

A가 B에게 작업 완료 후 실행하기를 원하는 콜백 함수를 같이 넘겨준다면(Async-Non-Blocking), A는 해당 작업에 대해 신경쓰지 않고 자신의 일을 끊김 없이 쭉 진행하고, B도 작업이 완료된 후 A가 넘겨준 콜백 함수를 수행합니다.  


## 정리

정리하자면 Async - NonBlocking 모델이 가장 리소스를 효율적으로 사용하는 모델이라고 할 수 있겠습니다.  
A는 B에게 요청한 일에 대해 요청만 한 후 신경 끄고 자기 일을 계속 할 수 있고, B도 알아서 요청 받은 일이 끝나면 콜백 함수로 작업의 마무리를 지으면 되기 때문입니다.  
동기가 아니기에 서로 계속 신호를 주고 받으며 완료 여부를 체크하는 리소스도 필요 없게 됩니다.  

이번 포스팅을 통해 비슷하면서 명확하게 다른 네 가지 개념을 ~~제가~~ 더 이상 헷갈리지 않기를 바라는 마음으로 이만 마치겠습니다.  
읽어주셔서 감사합니다!  


## 참고

- [자바 비동기 프로그래밍을 위한 CompletableFuture](https://brunch.co.kr/@springboot/267)
- [Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림](https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)
