# Sync / Async / Blocking / Non-Blocking
#TIL/concept

---

## 전제

어떤 **작업을 요청하는 클라이언트를 A**, **작업을 수행해서 결과를 돌려주는 친구를 B**라 하자.  


### Sync VS. Async

- 동기는 A와 B가 같이 간다. **같은 시간 선** 상에서 움직인다.
	- A가 B에게 작업을 요구하면 A는 B가 결과를 돌려줄 때까지 기다렸다가 결과를 받은 후에 작업한다.
	- A는 B가 결과를 늦게 돌려주던지, 바로 돌려주던지 상관 없이 어쨌든 결과를 받고 나서 나머지 일을 처리한다. 
		- **언제 돌려주는지는 상관없다**. 돌려받는 게 중요하다. 같은 시간 선 상에 있기 때문이다.

- 비동기는 A와 B가 따로 간다. **다른 시간 선** 상에서 움직인다.
	- A는 B에게 작업을 요구하면서 **결과가 준비된다면 수행해달라고 요청하는 콜백 함수**도 같이 넘긴다.
	- A는 B에게 요청한 후 **아무것도 신경쓰지 않는다**. 해당 작업에 대해서는 끝이다.
	- **요청을 받은 B가 오히려 받은 작업에 대해 신경쓰고** 결과에 대한 작업을 콜백 함수를 통해 처리한다.


### Blocking VS. NonBlocking

- Blocking은 A가 **기다리는 것**이다. B가 바로 결과를 돌려주기를 기다린다.
	- A는 오매불망 기다리기만 한다. B가 결과를 돌려주거나(Sync), 만약 콜백을 비동기로 넘겨줬다면 콜백 함수를 실행하기 까지를. (Async)

- NonBlocking은 B가 A에게 뭐가 됐든 **일단 바로 손에 뭔가를 쥐여준다**.
	- 결과를 바로 줄 수도 있지만, 보통은 결과를 주기엔 시간이 걸리니까 아직 준비가 덜 됐다는 실패했다는 신호라도 쥐여준다.
	- 뭔가 받긴 바로 받았으니까, A는 **자기가 해야할 다른 일들을 계속 이어서 해 나갈 수 있다**.
	- A와 B가 같은 시간 선 상에 있다면(Sync), A는 주기적으로 B의 완료 여부를 체크할 것이다. B가 작업을 완료할 때까지. 핑퐁핑퐁
	- A가 B에게 작업 완료 후 실행해달라고 요청하는 콜백 함수를 같이 넘겨준다면(Async), A는 그 일에 대해 신경 안쓰고 자기 일을 쭉 하고, B는 작업이 완료되면 받은 콜백 함수를 수행한다.


### 정리

Async - NonBlocking 모델이 가장 리소스를 효율적으로 사용하는 모델이다.  
A도 B에게 요청한 일에 대해 요청만 하고 신경 끄고 자기 일을 계속 할 수 있고, B는 요청 받은 일이 끝나면 콜백으로 마무리까지 지으면 된다.  
동기가 아니기에 서로 계속 신호를 주고 받으며 완료 여부를 체크할 필요도 없다.  


## 참고

- [CompletableFuture](https://brunch.co.kr/@springboot/267)
- [Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림](https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)
