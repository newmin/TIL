# 05. 데이터베이스
#TIL/aws/SAA

---

## 관계형 데이터베이스

### 온라인 트랜잭션 처리와 온라인 분석 처리

관계형 데이터베이스는 구성에 따라 온라인 트랜잭션 처리(OLTP, OnLine Transaction Processing)와 온라인 분석 처리(OLAP, OnLine Analytical Processing)로 나눌 수 있다.  

- OLTP  
	- OLTP 데이터베이스는 초당 몇 회씩 순차적으로 데이터를 빈번하게 읽고 쓰는 애플리케이션에 적합
	- 빠른 쿼리에 최적화
	- 이런 쿼리는 정기적이고 예측 가능한 경향이 있다.
	- 메모리가 상당히 필요할 수 있는데, 이는 빠른 액세스를 위해 자주 사용하는 테이블 일부를 메모리에 저장하기 때문
- OLAP  
	- OLAP 데이터베이스는 복잡한 대형 데이터 세트 쿼리에 최적화
	- 상당한 스토리지와 컴퓨팅이 필요하므로, 데이터웨어하우징 애플라케이션을 구축해 여러 OLTP 데이터베이스를 단일 OLAP 데이터베이스로 모으는 것이 일반적이다.

## Amazon Relational Database Service

### RDS

RDS를 사용해 데이터베이스를 배포할 때, 격리된 데이터베이스 환경인 데이터베이스 인스턴스 구성에서부터 시작한다.  
데이터베이스 인스턴스는 지정한 VPC 에 존재하나, EC2 인스턴스와는 다르게 AWS가 전적으로 데이터베이스 인스턴스를 관리한다.  
SSH를 사용해 액세스할 수 없으며, EC 2 인스턴스 사이에서도 보이지 않는다.  


### 데이터베이스엔진  

- MySQL
	- MySQL은 OLTP 애플리케이션용으로 설계
	- MySQL은 MyISAM과 InnoDB 두 가지 스토리지 엔진에서 하나를 선택할 수 있지만, 유일하게 RDS 관리형 자동 백업과 호환할 수 있는 엔진은 InnoDB이다.  
- MariaDB
	- MariaDB는 MySQL과 바이너리 수준의 호환성을 가지면서 기능을 향상한 데이터베이스
	- RDS와의 호환성을 최대화하기 위해 InnoDB를 사용할 것을 권장한다.
- Oracle
	- Oracle은 가장 널리 배포된 DBMS
- PostgreSQL
	- PostgreSQL은 스스로 가장 Oracle과 호환되는 오픈 소스 데이터베이스라고 홍보
- Amazon Aurora
	- Aurora는 Amazon이 MySQL과 PostgreSQL과 바이너리 수준의 호환성을 가지면서 기능을 향상시킨 데이터베이스
	- 가상 스토리지 계층을 사용해서 하부 스토리지 쓰기 횟수를 줄이기 때문에 MySQL과 PostgreSQL보다 쓰기 성능이 우수하다.
	- MySQL 호환 에디션에서 InnoDB 스토리지 엔진만 지원
	- MySQL에서 사용할 수 있는 Aurora Backtrack 기능으로 데이터베이스를 지난 72시간 이내 특정 시점으로 단 몇 초 만에 복구할 수 있다.    
- Microsoft SQL


### 데이터베이스옵션그룹  

옵션 그룹은 옵션이라는 관리 및 보안 기능을 지정해서 하나 이상의 인스턴스에 적용할 수 있게 한다.  
옵션을 사용하려면 메모리가 더 필요하므로 인스턴스에 충분한 메모리가 있는지 확인하고 필요한 것만 활성화해야 한다.  

옵션 그룹에서 사용 가능한 옵션은 데이터베이스 엔진마다 다르다.  

- Microsoft SQL Server와 Oracle
	- TDE(Transactional Data Encryption)를 제공해 스토리지에 쓰기를 수행하기 전에 엔진이 데이터를 암호화하게 한다.  
- MySQL과 MariaDB
	- 데이터베이스 사용자 로그인과 쿼리 활동을 기록하게 하는 감사 플러그인을 제공한다.  


### 데이터베이스 인스턴스 클래스  

데이터베이스 인스턴스를 시작할 때 처리 성능, 메모리, 네트워크 대역폭, 디스크 처리량이 어느 정도 필요한지 결정해야 한다.  
RDS는 데이터베이스 인스턴스 클래스를 다음 세 가지 유형으로 나눈다.  

- 표준  
	- 표준 인스턴스 클래스는 데이터베이스 요구를 대부분 충족한다.
- 메모리 최적화  
	- 메모리 최적화 인스턴스 클래스는 높은 처리 성능이 요구되는 데이터베이스용
	- 메모리를 더 많이 확보하고 있으면 메모리에 더 많은 데이터를 저장할 수 있으므로 쿼리 시간이 빨라진다. 
- 순간 확장 가능  
	- 순간 확장 가능 인스턴스는 개발, 테스트, 다른 비프로덕션 데이터베이스를 위한 인스턴스

데이터베이스 인스턴스는 EBS 스토리지를 사용한다.  
EBS 스토리지와의 데이터 전송을 위한 전용 대역폭을 제공하기 위해 표준과 메모리 최적화 인스턴스 클래스 유형은 EBS 최적화를 지원한다.  


### 스토리지  

데이터베이스 인스턴스에 적합한 스토리지 선택은 충분한 디스크 공간 확보 이상으로 중요하다.  

AWS는 초당 입력/출력 작업(IOPS)을 사용해 스토리지 성능을 측정한다.  
다른 모든 조건이 같을 때, IOPS가 큰 데이터베이스는 데이터를 저장하고 검색하는 속도가 더 빠르다.  

데이터베이스 스토리지의 속도는 할당된 IOPS 수에 제한된다.  
단일 I/O 작업에서 전송할 수 있는 데이터의 양은 데이터베이스 엔진이 사용하는 페이지 크기에 달려 있으며, 요구되는 IOPS 수준을 파악하려면 먼저 필요한 디스크 처리량을 알아야 한다.  

MySQL과 MariaDB의 페이지 크기는 16KB 이므로, 디스크에 16KB 의 데이터 쓰기가 하나의 I/O 작업을 구성한다.  
반면, Oracle, PostgreSQL, Microsoft SQL Server  는 8KB 크기의 페이지를 사용한다.  
페이지 크기가 클수록 단일 I/O 작업에서 더 많은 데이터를 전송할 수 있다.  

IOPS 수와 페이지 크기는 반비례 관계이다.  
페이지 크기가 클수록 같은 처리량을 달성하는 데 필요한 IOPS는 적어진다.  

스토리지 유형에 따라서 IOPS 수가 달라지며, AWS RDS는 다음 세 가지 유형의 스토리지를 제공한다.  

- 범용 SSD  
	- 데이터베이스 대부분은 범용 SSD 스토리지로 충분
	- RDS는 기본적으로 기가바이트당 3 IOPS 성능을 볼륨에 할당하며, 최대 10,000 IOPS까지 볼륨에 할당할 수 있다.  
	- 볼륨이 커지면 성능은 더 향상된다.
- 프로비저닝된 IOPS SSD(io1)
	- 프로비저닝된 IOPS SSD를 시용하면 인스턴스를 만들 때 필요한 IOPS 수를 간단하게 할당할수 있다.  
	- io1 스토리지에서는 순간 확장의 개념이 없다. 
	- 프로비저닝된 IOPS 수는 사용 여부와 관계없이 일정한 성능이 제공되고 그에 따른 비용이 청구되므로, 일관된 짧은 지연 시간에 성능이 필요한 OLTP 데이터베이스에 유용하다.  
	- 표준 또는 메모리 최적화 인스턴스 클래스를 사용할 때, RDS는 프로비저닝된 IOPS의 성능 변동 범위가 10% 이내로 유지되는 기간을 1년의 99.9%로 보장한다.
	- IOPS와 기가바이트 비율은 최소 50: 1(IOPS:GB) 이어야 한다.
- 마그네틱스토리지  
	- RDS는 구형 인스턴스의 호환성을 위해 마그네틱 스토리지를 제공한다.
	- 최대 크기는 4TB, 최대 성능은 1,000 IOPS 이다.


### 읽기전용복제본  

데이터베이스 인스턴스가 성능 요구 사항을 충족하지 못할 때 병목 현상 발생 위치에 따라 해결 방법을 적용할 수 있다.  

메모리, 컴퓨팅, 네트워크 속도, 디스크 처리량에 문제가 있을 때 더 큰 인스턴스 클래스로 업그레이드해서 데이터베이스를 수직 확장할수 있다.  
`수직 확장(5cale Up)`은 간단하게 실행할 수 있는 방식이며, 데이터베이스 인스턴스에 더 많은 리소스를 투여하므로 애플리케이션이나 데이터베이스를 변경하지 않아도 된다.  
`수평 확장(Scale Out)`은 읽기 전용 복제본이라는 추가 데이터베이스 인스턴스를 생성하는 작업이 뒤따른다.  
Oracle과 Microsoft SQL Server를 제외한 모든 데이터베이스 엔진은 읽기 전용 복제본을 지원하며, Aurora에는 Aurora 복제본이라는 특정 유형의 읽기 전용 복제본이 있다.  

읽기 전용 복제본은 데이터베이스 쿼리만 제공하는 데이터베이스 인스턴스로서, 마스터 데이터베이스 인스턴스의 쿼리 부하 부분을 맡는다.  
즉, 마스터 데이터베이스 인스턴스는 데이터 쓰기만을 책임지게 되므로, 읽기 작업량이 매우 많은 애플리케이션에 적합하다.  

RDS는 최대 5개 읽기 전용 복제본을 둘 수 있으며, Aurora에서는 최대 15개까지 둘 수 있다.  
데이터는 마스터로부터 모든 읽기 전용 복제본에 비동기로 복제되므로, 데이터가 마스터 데이터베이스에 저장되는 시점과 그 데이터가 복제본에 저장되는 시점에는 지연이 발생한다.  
따라서 읽기 전용 복제본은 재해 복구에 적합하지 않다.  

RDS는 읽기 전용 복제본을 만들변 도메인 이름을 제공하며, 이를 읽기 전용 엔드포인트라고 한다.  
RDS는 읽기 전용 복제본이 여러 개 있으면 해당 복제본 중 하나에 연결해 로드 밸런싱하므로, 사용자는 데이터를 읽기만을 하는 분석 도구가 있다면 그 도구에 읽기 전용 엔드포인트를 지정해주면 된다.  

읽기 전용 복제본과 마스터는 서로 다른 가용 영역에 둘 수 있으며 더 나아가 다른 리전에도 둘 수 있다.  
마스터 인스턴스에 장애가 발생했을 때 읽기 전용복제본을 마스터로 승격시킬 수 있지만, 비동기 복제의 특성이 존재하므로 어느 정도의 데이터  
손실은 감수해야 한다.  


### 고가용성 (다중-AZ)

데이터베이스 인스턴스가 중단돼도 데이터베이스를 계속 운영하려면, RDS의 다중 AZ 배포를 통해 여러 가용 영역에 데이터베이스 인스턴스 여러 개를 배포한다.  
다중 AZ 배포를 사용하면 한 가용 영역에 읽기 및 쓰기를 처리하는 기본 데이터베이스 인스턴스를 두고, 다른 가용 영역에는 예비 데이터베이스 인스턴스를 두게 되며, 기본 인스턴스가 중단되면 보통 2분 이내에 예비 인스턴스로 장애 조치가 수행된다.  

데이터베이스 인스턴스의 대표적인 중단 이유는 다음과 같다.  

- 가용영역중단  
* 데이터베이스 인스턴스 유형 변경  
- 인스턴스의 운영 체제 패치


#### Oracle, PostgreSQL, MariaDB, MySQL, Microsoft SQL Server에서 다중-AZ  

다중 AZ 배포시, 모든 인스턴스가 같은 리전에 있어야 한다.  
RDS는 주 인스턴스에서 예비 인스턴스로 데이터를 동기식으로 복제하는데, 이때 지연 시간이 발생 할 수 있으므로 EBS 최적화 인스턴스와 프로비저닝된 IOPS SSD 스토리지를 사용해야 한다.  

예비 인스턴스는 읽기 전용 복제본이 아니므로 읽기 트래픽을 처리할 수 없다.  
애플리케이션은 기본 인스턴스의 엔드포인트 도메인 이름에 연결하고, 장애 조치가 시작되면 RDS는 엔드포인트의 DNS 레코드가 예비 인스턴스로 향하도록 변경한다.   


#### Amazon Aurora에서 다중-AZ  

Amazon Aurora 클러스터는 기본 인스턴스로 구성되며, 항상 기본 인스턴스를 가리키는 클러스터 엔드포인트를 제공한다.  

기본 복제본과 모든 복제본은 단일 클러스터 볼륨을 공유한다.  
이 클러스터 볼륨은 3개 가용 영역에 걸쳐 동시에 복제되며, 필요에 따라 최대 64TB까지 자동으로 확장된다.  

기본 인스턴스에 장애가 발생했을 때 Aurora 복제본이 없으면 새로운 인스턴스를 생성하고, Aurora 복제본이 있으면 복제본을 기본 복제본으로 승격시킨다.  


### 백업과 복구

RDS는 데이터베이스 인스턴스의 EBS 볼륨 스냅샷 기능을 제공한다.  
인스턴스에 기반한 모든 데이터베이스는 스냅샷을 생성해서 S3에 저장할 수 있다.  
스냅샷은 중복성을 위해 같은 리전의 여러 영역에 보관된다.  

다중 AZ를 사용하지 않는 한 스냅샷을 하면 몇 초 동안 모든 I/O 작업이 일시 중단되므로 사용량이 적은 시간에 스냅샷을 만들어야 한다.  

백업 및 복구가 필요할 때 고려해야 할 두 가지 지표가 있다.  

- 복구 목표 시간(RTO, Recovery Time Objective)
	- 장애 후 데이터를 복구하고 처리를 재개하는 데까지 최대 허용 시간
- 복구 목표 지점(RPO, Recovery Point Objective)
	- 데이터 손실을 허용할 수 있는 최대 기간


### 자동화된 스냅샷

RDS는 매일 30분 백업 기간에 인스턴스 스냅샷을 자동 생성할 수 있으며, 이 기간은 사용자가 지정할 수도 있고 RDS가 자동으로 수행하게 할 수도 있다.  

자동 백업을 사용하면 특정 지점 복구가 가능해지며, 데이터베이스 변경 로그를 5분마다 S3로 저장한다.  
장애 이벤트가 발생하면 최대 5분 분량의 데이터만 손실된다.  

RDS는 자동화된 스냅샷을 일정 기간동안 유지하고, 기간이 지나면 삭제한다.  
사용자는 1일에서 35일 사이의 보존 기간을 선택할 수 있으며, 기본값은 7일이다.  
자동 스냅샷을 사용하지 않으려면 보존 기간을 0으로 설정한다.  
자동 스냅샷을 비활성화하면 기존의 자동화된 스냅샷 모두가 즉시 삭제되고, 특정 시점 복구가 비활성화된다.  
보존 기간을 0에서 다른 값으로 변경하면 즉시 스냅샷이 트리거된다.  

자동화된 스냅샷과 달리 수동 스냅샷은 삭제할 때까지 유지된다.  


### 유지 관리 항목

RDS는 관리형 서비스이므로 패치 및 업그레이드 처리는 AWS가 책임지며, 데이터베이스 인스턴스에서 운영 체제 보안과 안정성 패치 등의 유지 관리를 몇 달에 한 번씩 정기적으로 수행한다.  
메이저 버전 업그레이드에는 이전 버전과 호환하지 않는 데이터베이스 변경 사항이 포함돼 있을 수 있으므로, 메이저 버전 업그레이드는 사용자가 직접 적용해야 한다.  
데이터베이스를 다시 빌드할 필요가 없는 마이너 버전 변경은 자동으로 적용한다.  


## Amazon Redshift

Redshift는 OLAP 데이터베이스를 위해 설계된 PostgreSQL 기반의 관리형 데이터 웨어하우스 솔루션으로 RDS에 속해 있지는 않다.  
Redshift는 열 기반 스토리지를 사용해 서로 인접한 열에 값을 저장하므로, 저장 속도와 효율성이 향상되고 개별 열의 데이터를 더 빨리 쿼리할 수 있다.  


### 컴퓨팅 노드

Redshift 클러스터에는 두 가지 범주로 나눠진 하나 이상의 컴퓨팅 노드가 있다.  

- 고밀도 컴퓨팅 노드
	- 마그네틱 스토리지에 최대 326TB 데이터를 저장할 수 있다.
- 고밀도 스토리지 노드
	- 고속 SSD에 최대 2PB 데이터를 저장할 수 있다.

클러스터에 둘 이상의 컴퓨팅 노드가 있을 대 Redshift에는 클라이언트와 통신하고, 컴퓨팅 노드 간의 통신을 조정하는 리더 노드가 포함돼 있다.  

### 데이터 분산 스타일

Redshift 데이터베이스의 행은 컴퓨팅 노드에 걸쳐 분산되며, 데이터가 분산되는 방식은 분산 스타일에 따라 다르다.  

- EVEN
	- 기본 스타일
	- 리더 노드가 데이터를 모든 컴퓨팅 노드에 걸쳐 고르게 분산시킨다.
- KEY
	- 열 1개 값에 따라 데이터를 분산시킨다.
	- 같은 값을 가진 열은 같은 노드에 저장된다.
- ALL
	- 테이블이 컴퓨팅 노드에 분산된다.


## 비관계형 데이터베이스 (No-SQL)

비관계형 데이터베이스는 초당 수만 개의 트랜잭션을 일관성 있게 처리하도록 설계됐다.  
비관계형 데이터베이스는 `비정형 데이터`라고 하는 것에 최적화돼 있다.  
좀 더 정확한 표현은 `다중-정형 데이터`라고 할 수 있다.  
비관계형 데이터베이스에 저장하는 데이터의 형태는 다양하고 계속 변경할 수 있다.  

비관계형 No-SQL 데이터베이스는 컬렉션으로 구성된다.  
컬렉션은 때로는 테이블이라고 불리며, 관계형 데이터베이스에서 행 또는 튜플 개념과 유사한 항목이 테이블에 저장된다.  


### 데이터 저장

비관계형 데이터베이스가 관계형 데이터베이스와 가장 크게 다른 점은 스키마가 없고 테이블의 모든 항목이 같은 속성을 갖도록 요구하지 않는다는 것이다.  
비관계형 데이터베이스는 저장 데이터 형식이 유연할 때 사용하며, 테이블을 만들 때 기본 키 속성 외에는 속성을 미리 정의하지 않아도 된다.  
항목을 작성하거나 수정할 때 바로 속성을 작성하는데, 이 때의 속성은 순서가 없고 서로 관계도 없으므로 비관계형이라고 부른다.  

비관계형 데이터베이스에서는 여러 테이블에 걸쳐 데이터베이스를 나눈 뒤 이 데이터베이스를 병합해서 쿼리할 수 있는 방법이 없다.  
이 때문에 애플리케이션에서 모든 데이터를 하나의 테이블에 보관하는 경우가 있는데, 이는 데이터 중복으로 이어지고 데이터베이스가 커지면서 심각한 스토리지 비용이 발생할 수 있다.  


### 데이터 쿼리

비관계형 데이터베이스는 비정형 데이터를 저장할 수 있다는 유연성이 있지만, 쿼리가 제한돼 있다는 단점이 따르며, 기본 키 기반의 쿼리에 최적화돼 있다.  


### 비관계형 데이터베이스 유형

- 키-값 저장소
	- 기본적으로 모든 비관계형 데이터베이스는 키-값 저장소 데이터베이스이다.  
- 문서 지향적 저장소
	- 값으로 저장된 문서의 내용을 분석하고 메타 데이터를 추출하는 특정한 비관계형 데이터베이스 애플리케이션이다. 
- 그래프 데이터베이스
	- 여러 항목에 있는 속성 간의 관계를 분석한다.


## DynamoDB

DynamoDB는 초당 수천 개 읽기 및 쓰기를 처리할 수 있는 관리형 비관계형 데이터베이스 서비스이다.  
데이터를 여러 파티션에 걸쳐 분산시켜서 이러한 성능을 얻는다.  
파티션은 테이블 스토리지 할당으로, 여러 가용 영역의 SSD에 백업된다.  


### 파티션 / 해시 키

테이블을 만들 때 기본 키와 데이터 형식을 지정해야 한다.  
기본 키는 테이블의 항목을 고유하게 식별하므로 그 값은 테이블 내에서 유일해야 한다.  

기본 키 유형은 두 가지가 있다.  

- 파티션 키 (해시 키)
	- 단일 값을 가지는 기본 키
	- 파티션 키만 기본 키로 사용하는 경우 `단순 기본 키`라고 한다.
	- 파티션 키로 저장할 수 있는 최대 크기는 2048바이트이다.
- 파티션 키 + 정렬 키
	- `복합 기본 키`라고 한다.
	- 파티션 키는 고유할 필요 없다.
	- 파티션 키와 정렬 키의 조합은 고유해야 한다.
	- 정렬 키로 저장할 수 있는 최대 크기는 1024바이트이다.

DynamoDB는 기본 키를 기반으로 파티션에 걸쳐 항목을 배포한다.  
DynamoDB는 정렬 키를 사용해서 오름차순으로 항목을 정렬한다.

대량의 읽기 쓰기 작업이 발생하는 파티션을 `핫 파티션`이라고 한다.  
이는 성능에 부정적인 영향을 줄 수 있다.  
핫 파티션을 피하려면 파티션 키를 최대한 고유하게 만들어야 한다.  


### 속성과 항목

각 키-값 페어는 속성을 구성하고, 하나 이상의 속성은 항목을 구성한다.  
DynamoDB가 저장할 수 있는 항목의 최대 크기는 400KB이다.  

모든 항목은 최소한 기본 키와 키에 해당하는 값을 가지고 있다.  
속성을 생성할 때는 데이터 형식을 정해야 하며, 다음 세 가지 범주로 정할 수 있다.  

- 스칼라
	- 스칼라 데이터 형식은 하나의 값만 가질 수 있다.
- 집합
	- 집합 데이터 형식은 순서가 없는 스칼라 값 목록을 담고 있다.
- 문서
	- 문서 데이터 형식은 스칼라와 집합 데이터 형식의 제약을 벗어나느 여러 형식의 데이터를 담을 수 있도록 설계됐으며, 최대 32레벨까지 문서 형식을 중첩할 수 있다.  


### 처리 용량

테이블을 만들 때 애플리케이션에 필요한 초당 읽기 및 쓰기 횟수를 지정해야 하며, 이를 `프로비저닝된 처리량`이라고 한다.  
DynamoDB는 테이블을 만들 때 지정한 읽기 용량 단위(RCU, Read Capaciry Units) 및 쓰기 용량 단위(WCU, Write Capacity Units) 갯수로 파티션을 예약한다.  

`강력한 일관된 읽기` 또는 `최종적 일관된 읽기`로 테이블에서 항목을 읽을 수 있다.  

- 강력한 일관된 읽기
	- 항상 최신 데이터를 제공한다.
- 최종적 일관된 읽기
	- 최근 쓰기 작업의 데이터를 반영하지 못하는 이전 데이터를 만들어 낸다.

강력한 일관성을 사용하느냐 최종적 일관성을 사용하느냐는 애플리케이션이 이전 데이터 읽기를 허용할 수 있는지에 달려 있으며, 프로비저닝할 처리량을 결정할 때 어떤 유형의 읽기가 필요한지 파악해야 한다.  

최대 4KB 크기의 항목을 기준으로 할 때, 1개의 RCU는 1개의 강력한 일관된 초당 읽기를 제공한다.  
1개의 RCU는 초당 2개의 최종적 일관된 읽기를 제공한다.  

1개의 WCU는 최대 1KB 크기의 항목 1개 쓰기를 제공한다.  

DynamoDB가 제공하는 최대 처리 용량은 사용자가 지정하며, 이를 초과하면 DynamoDB는 요청을 차단하고 HTTP 400 오류를 발생시킬 수 있다.  

테이블에 얼마만큼 처리량을 프로비저닝해야 할지 정확하지 않거나 시간에 따라 처리량의 요구가 달라질 것으로 예상할 때 Auto Scaling을 구성해서 정해 놓은 임계치에 가깝게 도달하면 자동으로 프로비저닝된 처리량을 증가하게 할 수 있다.  
Auto Scaling을 구성할 때 최소/최대 RCU와 WCU를 지정하고, 목표 사용률을 지정한다.  

적절한 사용률을 설정하면 작업에 균형을 이룰 수 있으나, 사용률을 높게 설정할수록 프로비저닝된 용량을 초과할 가능성은 커지고, 요청이 제한될 수 있다.  
반면 사용률을 너무 낮게 설정하면 필요하지 않은 용량에 비용을 지급하게 한다.  

100 이상의 WCU나 RCU가 필요할 때 예약 처리 용량을 구매해서 비용을 절약할 수 있다.  


### 데이터 읽기

DynamoDB는 테이블에서 두 가지 방식으로 데이터를 읽는다.  

- 스캔
	- 모든 테이블 항목을 나열한다.
	- 읽기 집약적 작업이므로 프로비저닝된 용량 단위를 모두 사용할 가능성이 있다.
- 쿼리
	- 파티션 키값을 기반으로 항목을 반환한다.
	- 쿼리를 수행할 때 검색하는 파티션 키의 값은 항목의 값과 정확히 일치해야 한다.

보조 인덱스는 DynamoDB에서 데이터를 쿼리할 때 발생하는 두 가지 문제를 해결한다.  
사용자는 특정 항목을 쿼리할 때 파티션 키를 정확하게 지정해야만 한다.  
보조 인덱스를 사용하면 테이블의 기본 키 외의 속성으로 데이터를 찾을 수 있으므로, 보조 인덱스를 테이블이 지닌 일부 속성의 복사본이라고 할 수 있다.  

보조 인덱스를 만들 때 기본 테이블에서 인덱스로 복사할 속성을 선택할 수 있는데, 이를 프로젝션된 속성이라고 한다.  
보조 인덱스는 항상 기본 테이블의 파티션 키와 정렬 키 속성을 포함한다.  

- 글로벌 보조 인덱스(GSI, Global Secondary Index)
	- 테이블을 만든 후에 언제든지 글로벌 보조 인덱스를 만들 수 있다.
	- 파티션 키와 해시 키는 기본 테이블과 다를 수 있지만, 기본 키 선택과 같은 규칙이 여전히 적용된다.
	- 글로벌 보조 인덱스에서 읽을 때는 항상 읽기 일관성이 유지된다.
- 로컬 보조 인덱스(LSI, Local Secondary Index)
	- 기본 테이블과 동시에 만들어져야 하며 일단 만들면 삭제할 수 없다.
	- 파티션 키는 항상 기본 테이블과 같아야 하지만 정렬 키는 다를 수 있다.
	- 로컬 보조 인덱스의 읽기는 읽기 시간을 얼마로 지정하냐에 따라 강력한 일관성 또는 최종적 일관성이 될 수도 있다.








































