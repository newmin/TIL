# Real MySQL - 12. 쿼리 종류별 잠금
#TIL/Database/RealMySQL

---

## InnoDB의 기본 잠금 방식
InnoDB에서는 각 쿼리의 패턴별로 사용하는 잠금이 다르다.  
먼저 기본적으로 각 쿼리가 어떤 잠금 방식을 사용하는지 알아보자.  


### SELECT

REPEATABLE-READ 이하의 트랜잭션 격리 수준에서 InnoDB 테이블에 대한 SELECT 쿼리는 기본적으로 아무런 잠금도 사용하지 않는다.  
또한 이미 잠긴 레코드를 읽는 것도 아무런 제약이 없다.  

SELECT 쿼리로 읽은 레코드를 잠그는 방법은 읽기 모드와 쓰기 모드 잠금으로 두 가지가 있다.  

```sql
SELECT * FROM sample_tbl WHERE col1 = 10001 LOCK IN SHARE MODE;
SELECT * FROM sample_tbl WHERE col1 = 10001 FOR UPDATE;
```

LOCK IN SHARE MODE는 읽기 잠금만 걸기 때문에 잠금을 획득한 트랜잭션에서도 변경하려면 쓰기 잠금을 다시 획득해야 한다.  
그래서 변경이 같이 필요하다면 처음부터 FOR UPDATE를 거는 것이 좋다.  

위 잠금 읽기는 COMMIT이나 ROLLBACK이 실행되면 잠금이 해제되므로 반드시 하나의 트랜잭션에서만 유효하다.  
만약 하나의 트랜잭션 안에서 두 가지 요청이 일어나는 경우, 첫 번째 요청에서 FOR UPDATE 등의 잠금이 걸린 채 과정이 종료되면 해당 커넥션은 대기 상태에 빠지는 위험이 있을 수 있다.  
따라서 잠금 읽기는 항상 FINALLY 구문으로 트랜잭션의 종료를 보장해야 한다.  


### INSERT, UPDATE, DELETE

모두 기본적으로 쓰기 잠금을 사용하며, 필요 시에는 읽기 잠금을 사용할 수도 있다.  

InnoDB에서는 UPDATE, DELETE 문장으로 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조하는 인덱스의 모든 레코드에 잠금을 건다.  
이는 해당 쿼리의 WHERE 조건에 일치하지 않는 레코드라도 잠금의 대상이 될 수 있음을 의미한다.  

레코드에 잠금을 거는 주체는 InnoDB 스토리지 엔진이고, 업데이트할 레코드를 최종 결정하는 것은 MySQL 엔진인데, MySQL 엔진은 **WHERE 절의 모든 조건이 아니라 인덱스를 사용할 수 있는 조건만 InnoDB 스토리지 엔진으로 전달하기 때문**이다.  
따라서 InnoDB 스토리지 엔진은 해당 인덱스의 모든 레코드에 잠금을 걸 수밖에 없다.  

그러므로 테이블 크기와 상관 없이 UPDATE, DELETE 실행 시에도 인덱스의 생성을 고려해야 한다.  
해당 UPDATE, DELETE 쿼리가 이용할 인덱스가 없다면 InnoDB 스토리지 엔진은 모든 레코드를 대상으로 잠금을 걸 것이기 때문이다.  

"테이블의 레코드 건수가 적어서 인덱스를 생성하지 않아도 된다"라는 생각 보다는 "테이블의 레코드가 적으므로 인덱스를 더 생성해도 무리가 가지 않을 것이다"라고 생각을 바꿔야 한다.  

> 복제를 사용하지 않는 MySQL 서버에서는 바이너리 로그를 사용하지 않는 것을 고려해 볼 수 있다.
> 바이너리 로그를 사용하지 않는다면 트랜잭션 격리 레벨을 REPEATABLE-READ 대신 READ-COMMITTED로 사용할 수도 있다.
> 이 때 READ-COMMITTED에서는 인덱스와 관계 없이 실제 변경되는 레코드만 잠금을 걸게 된다.
> 
> 하지만 이는 인덱스 조건으로 먼저 검색해 잠금을 건 후, 대상이 아닌 레코드는 다시 잠금을 해제하는 방식이기 때문에 결론적으로는 READ-COMMITTED 격리 레벨이더라도 인덱스를 사용할 수 있게 해주는 것이 좋다.  

---

























