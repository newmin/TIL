# Real MySQL - 3. 아키텍처
#TIL/Database

---

## MySQL 아키텍처

### MySQL의 전체 구조

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분해서 볼 수 있다.  

- MySQL 엔진 : 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 그리고 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다. 또한 성능 향상을 위해 캐시나 버퍼 풀과 같은 보조 저장소 기능이 포함돼 있다.  
- 스토리지 엔진 : 위의 MySQL 엔진이 쿼리 분석 및 최적화 등의 두뇌 활동을 담당하고, 실제 데이터를 디스크에 저장하거나 디스크에서 데이터를 읽어오는 부분은 스토리지 엔진이 처리한다.  
	- MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.  
	- 'CREATE TABLE test_table (col1 INT, col2 INT) ENGINE = INNODB' 와 같은 식으로 테이블을 생성하면, 해당 테이블의 모든 CRUD 작업은 InnoDB 스토리지 엔진이 처리한다.  
- 핸들러 API : MySQL 엔진의 쿼리 실행기에서 데이터의 쓰기/읽기가 필요한 경우에는 스토리지 엔진에게 쓰기/읽기를 요청하는데, 이러한 요청을 핸들러 요청이라고 하고, 여기서 사용되는 API 를 핸들러 API 라고 한다.


### MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있다.  

- 포그라운드 스레드 (클라이언트 스레드) : 최소 서버에 접속한 클라이언트의 수만큼 존재하며, 각 사용자가 요청한 쿼리 문장을 수행하는 역할을 갖고 있다.  
	- 사용자가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 스레드 캐시(Thread Pool)로 돌아가는데, 이 때 스레드 캐시에 일정 개수 이상의 대기 스레드가 있으면 해당 스레드는 종료시킨다.
	- thread_cache_size 가 해당 스레드 캐시의 스레드 수를 설정하는 값이다.
	- 데이터를 데이터 버퍼나 캐시로부터 가져오며, 해당 부분에 데이터가 없는 경우에는 디스크나 인덱스로부터 데이터를 읽어와서 작업을 처리한다.  
- 백그라운드 스레드 : InnoDB의 경우에는 여러 작업이 백그라운드로 처리된다.  
	- 인서트 버퍼를 병합하는 스레드, 로그를 디스크로 기록하는 스레드, InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드, 데이터를 버퍼로 읽어들이는 스레드, 잠금이나 데드락을 모니터링하는 스레드, 이 모든 것을 총괄하는 메인 스레드 등이 있다.
	- 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 하는 쓰기 스레드이다.


### 메모리 할당 및 사용 구조

MySQL 에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 나눌 수 있다.  
글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 무조건 OS로부터 할당된다.  

- 글로벌 메모리 영역 : 클라이언트 스레드 수와 무관하게 일반적으로 하나의 메모리 공간만 할당된다.
- 로컬 메모리 영역 : 세션 메모리 영역이라고도 한다. 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
	- 대표적으로 커넥션 버퍼와 소트(정렬) 버퍼가 있다.
	- 각 클라이언트 별로 독립적으로 할당된다.


### 플러그인 스토리지 엔진

MySQL 에서 쿼리가 실행되는 과정은 다음과 같다.  

1. SQL 파서
2. SQL 옵티마이저
3. SQL 실행기
4. 데이터 읽기/쓰기
5. 디스크 스토리지

이 중에서 1~3번과 같이 대부분의 작업이 MySQL 엔진에서 처리되고, 4번 데이터 읽기/쓰기 작업만 스토리지 엔진에 의해 처리된다.  
비유하자면 MySQL 엔진은 사람 역할, 각 스토리지 엔진은 자동차 역할인데, 이 때 MySQL 엔진이 스토리지 엔진을 조정하기 위한 객체를 핸들러라고 한다.

중요한 것은 하나의 쿼리 작업이 여러 하위 작업으로 나뉘는데, **각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 아는 것**이다.  
예를 들어 실질적인 GROUP BY나 ORDER BY 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 쿼리 실행기에서 처리된다.  

### 쿼리 실행 구조

쿼리가 실행되는 순서대로 각 부분에 대해 알아보자.  

- 파서 : 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업이다.  
	- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견된다.  
- 전처리기 : 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점을 확인한다.  
	- 각 토큰을 테이블 이름, 칼럼 이름, 내장 함수 등을 매핑해서 해당 객체의 존재 여부와 접근 권한 등을 확인한다.
- 옵티마이저 : DBMS의 두뇌로, 쿼리 문장을 어떻게 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 한다.
- 실행 엔진 : 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 한다.  
- 핸들러(스토리지 엔진) : MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 한다.  


### 복제

복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.  

- 마스터 : MySQL 의 `바이너리 로그`가 활성화되면 마스터가 될 수 있다.  
	- 마스터 서버에서 실행되는 DML, DDL 중 데이터의 구조나 내용을 변경하는 모든 쿼리 문장은 바이너리 로그로 기록되었다가, 슬레이브 서버에서 변경 내역을 요청하면 해당 로그를 읽어 슬레이브로 넘긴다.
- 슬레이브 : 바이너리 로그를 받아올 마스터의 접속 정보를 가지고 있는 경우 슬레이브가 된다. 
	- 슬레이브 서버는 릴레이 로그를 가지고 있다.
	- 보통 읽기 전용 설정을 활성화한다.
	- 슬레이브 서버는 마스터에 접속해 변경 내역을 받아서 릴레이 로그에 기록하고, SQL 스레드가 릴레이 로그에 기록된 변경 내역을 재실행함으로써 데이터를 마스터와 동기화한다.

복제에서 주의해야 하는 점은 다음과 같은 것들이 있다.  

- 슬레이브는 하나의 마스터만 설정 가능
- 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버는 마스터와 동일한 사양이 적합
	- 슬레이브가 마스터보다 사양이 더 적어도 될 것이라 생각할 수도 있지만, 마스터에서 수많은 사용자가 동시 실행한 데이터 변경 쿼리를 슬레이브에서 하나의 스레드로 처리해야하기 때문에 오히려 슬레이브가 사양이 더 높아야 한다.
	- 하지만 데이터 변경이 조회보다는 현저히 적기 때문에 마스터와 슬레이브 서버는 보통 같은 사양으로 구성하면 된다.
- 복제가 불필요한 경우에는 바이너리 로그를 중지한다.
	- 바이너리 로그는 성능에 많은 영향을 준다. 

