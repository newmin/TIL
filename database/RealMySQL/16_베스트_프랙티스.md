# Real MySQL - 16. 베스트 프랙티스
#TIL/Database/RealMySQL

---

## 페이징 쿼리

### 기존 페이징 쿼리의 문제점

페이징 쿼리는 기본적으로 뒤로 갈수록 느려지는 쿼리이다.  
보통 offset과 limit으로 구현을 하는데, 해당 offset 지점을 찾기 위해 정렬된 첫 레코드부터 offset 지점까지 모든 레코드를 읽어서 버리고, 그 다음 limit 사이즈만큼 레코드를 읽어서 반환한다.  
해당 쿼리가 인덱스를 이용해서 레코드를 읽는다면 그나마 다행이지만, 인덱스도 사용하지 못하는 쿼리라면 읽고 버릴 레코드를 매번 디스크에서 조회하는 일도 발생하게 된다.  

### 불필요한 접근을 제거한 페이징 쿼리

해결책은 쿼리의 조건절에 offset을 한번에 찾을 수 있는 프라이머리 키의 조건을 넣으면 된다는 것이다.  
마지막으로 읽었던 레코드의 id 값을 기준으로 조건에 넣어주면, 해당 id를 기점으로 필요없는 레코드는 읽지 않고 건너뛸 수 있다.  

다만 LIKE나 IN, BETWEEN 같이 범위 조건이 사용될 때는 주의가 필요하다.  
다음과 같이 ORDER BY 절에서 사용된 칼럼과 WHERE 절의 범위 조건에 사용된 칼럼이 다른 쿼리는 인덱스를 어떻게 만들어도 사용할 수가 없게 된다.  
아래 쿼리 테이블에 인덱스가 (col_1, col_2, col_3) 으로 만들어져 있는 상태에서 col3으로 페이징 쿼리 조건을 추가하면 잘못된 결과를 만들어낼 수 있다.  

```sql
SELECT *
FROM sample_tbl
WHERE col_1 = 1
  AND col_2 IN ('A', 'B')
ORDER BY col_3
DESC LIMIT 0, 20;
```


## MySQL에서 시퀀스 구현

### 시퀀스와 AUTO_INCREMENT

RDBMS에서 일련번호를 발급하는 기능으로는 **오라클의 시퀀스**와 **MySQL의 AUTO_INCREMENT**가 있다.  
AUTO_INCREMENT 기능은 테이블의 일부라서  관리가 용이하지만 가장 큰 단점은 여러 테이블에 걸쳐 유일한 일련번호를 만들어낼 수 없다는 점이다.  
가끔은 MySQL에서도 특정 테이블에 의존적이지 않고 독립적으로 일련번호만 발급하는 기능이 필요할 때가 있다.  

### 시퀀스용 테이블

MySQL에서 시퀀스를 구현하려면 현재의 시퀀스 값이 저장된 테이블이 필요하다.  

```sql
CREATE TABLE mysql_sequences (
  seq_name VARCHAR(10) NOT NULL,
  seq_currval BIGINT UNSIGNED NOT NULL,
  PRIMARY KEY (seq_name)
) ENGINE = MyISAM;
```

이 테이블에서 가장 중요한 것은 seq_name이 프라이머리 키로 지정된 것과 스토리지 엔진이 MyISAM이라는 것이다.  
InnoDB 엔진으로 시퀀스 테이블을 생성하면 트랜잭션의 잠금 때문에 성능 저하를 유발하게 된다.  

시퀀스는 다음과 같이 생성할 수 있다.  

```sql
INSERT INTO mysql_sequences
  SET seq_name='시퀀스 이름', seq_currval=(@v_current_value:=1)
on duplicate KEY
  UPDATE seq_currval=(@v_current_value:=seq_currval+1);
```

위 쿼리에서는 INSERT가 되든 UPDATE가 되든 관계 없이 사용자 정의 세션 변수인 @v_current_value에 시퀀스 값이 업데이트가 된다.  
따라서 시퀀스를 조회할 때는 SELECT 쿼리를 날릴 필요 없이 세션 변수를 참조하면 된다.  

## 큰 문자열 칼럼의 인덱스 (해시)

### 해시 값으로 인덱스 생성하기

가끔 아주 긴 문자열 칼럼에 인덱스를 생성해야 하는 경우가 생길 수 있다.  
**프리픽스 인덱스**는 칼럼의 앞 부분 767바이트만 잘라서 프라이머리 키나 유니크 키로 생성하는 인덱스를 말하는데, 대신 앞 767 바이트만으로 유니크해야 한다는 제약이 있다.  

이 때는 긴 문자열을 MD5() 함수나 SHA() 함수를 이용해 해시값을 만들어 인덱스를 생성하면 해결할 수 있다.  
조회 시에는 조회하려는 조건의 문자열을 해시 값으로 만들어 비교하면 된다.  
























