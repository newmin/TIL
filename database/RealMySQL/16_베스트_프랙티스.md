# Real MySQL - 16. 베스트 프랙티스
#TIL/Database/RealMySQL

---

## 페이징 쿼리

### 기존 페이징 쿼리의 문제점

페이징 쿼리는 기본적으로 뒤로 갈수록 느려지는 쿼리이다.  
보통 offset과 limit으로 구현을 하는데, 해당 offset 지점을 찾기 위해 정렬된 첫 레코드부터 offset 지점까지 모든 레코드를 읽어서 버리고, 그 다음 limit 사이즈만큼 레코드를 읽어서 반환한다.  
해당 쿼리가 인덱스를 이용해서 레코드를 읽는다면 그나마 다행이지만, 인덱스도 사용하지 못하는 쿼리라면 읽고 버릴 레코드를 매번 디스크에서 조회하는 일도 발생하게 된다.  

### 불필요한 접근을 제거한 페이징 쿼리

해결책은 쿼리의 조건절에 offset을 한번에 찾을 수 있는 프라이머리 키의 조건을 넣으면 된다는 것이다.  
마지막으로 읽었던 레코드의 id 값을 기준으로 조건에 넣어주면, 해당 id를 기점으로 필요없는 레코드는 읽지 않고 건너뛸 수 있다.  

다만 LIKE나 IN, BETWEEN 같이 범위 조건이 사용될 때는 주의가 필요하다.  
다음과 같이 ORDER BY 절에서 사용된 칼럼과 WHERE 절의 범위 조건에 사용된 칼럼이 다른 쿼리는 인덱스를 어떻게 만들어도 사용할 수가 없게 된다.  
아래 쿼리 테이블에 인덱스가 (col_1, col_2, col_3) 으로 만들어져 있는 상태에서 col3으로 페이징 쿼리 조건을 추가하면 잘못된 결과를 만들어낼 수 있다.  

```sql
SELECT *
FROM sample_tbl
WHERE col_1 = 1
  AND col_2 IN ('A', 'B')
ORDER BY col_3
DESC LIMIT 0, 20;
```

---

## MySQL에서 시퀀스 구현

### 시퀀스와 AUTO_INCREMENT

RDBMS에서 일련번호를 발급하는 기능으로는 **오라클의 시퀀스**와 **MySQL의 AUTO_INCREMENT**가 있다.  
AUTO_INCREMENT 기능은 테이블의 일부라서  관리가 용이하지만 가장 큰 단점은 여러 테이블에 걸쳐 유일한 일련번호를 만들어낼 수 없다는 점이다.  
가끔은 MySQL에서도 특정 테이블에 의존적이지 않고 독립적으로 일련번호만 발급하는 기능이 필요할 때가 있다.  

### 시퀀스용 테이블

MySQL에서 시퀀스를 구현하려면 현재의 시퀀스 값이 저장된 테이블이 필요하다.  

```sql
CREATE TABLE mysql_sequences (
  seq_name VARCHAR(10) NOT NULL,
  seq_currval BIGINT UNSIGNED NOT NULL,
  PRIMARY KEY (seq_name)
) ENGINE = MyISAM;
```

이 테이블에서 가장 중요한 것은 seq_name이 프라이머리 키로 지정된 것과 스토리지 엔진이 MyISAM이라는 것이다.  
InnoDB 엔진으로 시퀀스 테이블을 생성하면 트랜잭션의 잠금 때문에 성능 저하를 유발하게 된다.  

시퀀스는 다음과 같이 생성할 수 있다.  

```sql
INSERT INTO mysql_sequences
  SET seq_name='시퀀스 이름', seq_currval=(@v_current_value:=1)
on duplicate KEY
  UPDATE seq_currval=(@v_current_value:=seq_currval+1);
```

위 쿼리에서는 INSERT가 되든 UPDATE가 되든 관계 없이 사용자 정의 세션 변수인 @v_current_value에 시퀀스 값이 업데이트가 된다.  
따라서 시퀀스를 조회할 때는 SELECT 쿼리를 날릴 필요 없이 세션 변수를 참조하면 된다.  

---

## 큰 문자열 칼럼의 인덱스 (해시)

### 해시 값으로 인덱스 생성하기

가끔 아주 긴 문자열 칼럼에 인덱스를 생성해야 하는 경우가 생길 수 있다.  
**프리픽스 인덱스**는 칼럼의 앞 부분 767바이트만 잘라서 프라이머리 키나 유니크 키로 생성하는 인덱스를 말하는데, 대신 앞 767 바이트만으로 유니크해야 한다는 제약이 있다.  

이 때는 긴 문자열을 MD5() 함수나 SHA() 함수를 이용해 해시값을 만들어 인덱스를 생성하면 해결할 수 있다.  
조회 시에는 조회하려는 조건의 문자열을 해시 값으로 만들어 비교하면 된다.  

---

## 복제 설정

### 복제를 사용하지 않는 MySQL의 설정

MySQL에서 복제를 사용하려면 바이너리 로그 파일이 활성화돼야 한다.  
MySQL의 시스템 설정 값 중 "log-bin"이라는 설정에 파일 이름이나 경로가 명시되면 MySQL은 무조건 바이너리 로그를 활성화한다.  

하지만 바이너리 로그는 상당히 고비용의 디스크 I/O 작업을 필요로 하며, 내부적으로 갭 락과 넥스트 키 락을 사용한다.  

따라서 복제를 사용하지 않는 MySQL 서버에서는 바이너리 로그를 비활성화하고, InnoDB가 갭 락과 넥스트 키 락을 사용하지 않게 트랜잭션 격리 수준을 READ-COMMITTED로 사용하는 것이 좋다.  


### 복제 구축

MySQL의 복제는 "하나의 슬레이브 MySQL이 둘 이상의 마스터 MySQL을 가질 수 없다"라는 제약만 피한다면 어떤 형태로든 구성할 수 있다.  

슬레이브 MySQL 서버는 설정 파일에 "read_only" 시스템 설정을 추가해 읽기 전용으로 설정해서 마스터와 슬레이브 간 데이터가 달라지지 않게 해준다.  
하지만 "read_only" 설정으로 기동된 MySQL 서버에서도 SUPER 권한을 가진 사용자는 데이터를 변경할 수 있으므로 일반 사용자에게 SUPER 권한을 부여하지 않도록 주의해야 한다.  

MySQL의 복제는 비동기 방식으로 데이터가 전달된다.  
이는 마스터에서 커밋된 데이터가 커밋된 시점에 슬레이브에는 반영되지 않았을 수도 있다는 것을 의미한다.  
따라서 데이터를 변경함과 동시에 SELECT하는 쿼리는 마스터 MySQL 서버에서 실행하는 것이 좋다.  
물론 특별한 상황이 아니라면 해당 데이터의 동기화 작업은 0.1초 내로 완료될 것이다.  

---

## SQL 작성 표준

실수를 방지할 수 있는 SQL 표준 작성법을 알아보자.  

- 조인 조건은 항상 ON절에 기재한다.
	- OUTER JOIN이면서 조인 조건을 WHERE 절에 기술하면, MySQL 옵티마이저가 INNER JOIN으로 고쳐서 실행하기 때문에 원하는 결과가 나오지 않을 수 있다.
- 테이블 Alias 별칭을 부여하고, 칼럼에 테이블 별칭을 포함한다.
	- 테이블 간 같은 이름의 칼럼은 충분히 발생할 수 있다. (새로 추가될 수도 있다.)
- 서버 사이드 프리페어 스테이트먼트 사용
- 문자열 리터럴 표기는 홑따옴표만 사용
- 서브 쿼리는 조인으로 변경
- UNION (ALL) 은 사용 자제
	- 항상 내부적으로 임시 테이블을 만들어 버퍼링한 다음에 사용자에게 결과를 반환한다.
- 숫자 값은 반드시 숫자 타입의 칼럼으로 정의한다.






