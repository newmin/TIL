# Real MySQL - 7. 쿼리 작성 및 최적화 (2)

## INSERT

### AUTO_INCREMENT

MySQL에서는 순차적으로 증가하는 숫자 값을 가져오기 위해 AUTO_INCREMENT라는 기능을 제공한다.  

AUTO_INCREMENT는 테이블의 칼럼에 부여하는 옵션 형태로 사용하므로 자동 증가 기능은 하나의 테이블에서만 순차적으로 증가하게 된다.  

#### INSERT 쿼리에서 ID를 직접 지정하는 경우

```sql
CREATE TABLE sample_tbl (
  member_id INT NOT NULL AUTO_INCREMENT,
  member_name VARCHAR(30) NOT NULL,
  PRIMARY KEY (member_id)
) ENGINE=INNODB;

INSERT INTO sample_tbl (member_name) VALUES ('Georgi Fellona');
INSERT INTO sample_tbl (member_id, member_name) VALUES (5, 'Georgi Fellona');
```

첫 번째 쿼리는 primary key인 id를 지정하지 않았지만, AUTO_INCREMENT에 의해 자동으로 다음 id값이 부여된다.  

두 번째 쿼리는 id를 직접 지정한 경우이다.  
- 강제 저장한 값이 AUTO_INCREMENT의 현재 값보다 작을 때는 AUTO_INCREMENT의 현재 값이 변하지 않는다.  
- 강제 저장한 값이 AUTO_INCREMENT의 현재 값보다 클 때는 현재 값에 관계 없이 지정한 값에 1을 더한 값이 AUTO_INCREMENT의 다음 값으로 변경된다.  

#### AUTO_INCREMENT 잠금

여러 커넥션에서 AUTO_INCREMENT를 동시에 사용할 때는 동기화 처리가 필요하다.  
이를 위해 MySQL에서는 AutoIncrement 잠금이라는 `테이블 단위의 잠금`을 사용한다.  

`테이블 단위의 잠금`이란 특정 시점을 잘라서 볼 때 한 테이블의 AutoIncrement 잠금은 반드시 하나의 커넥션만 가질 수 있다는 것을 의미한다.  

하지만 AutoIncrement 잠금은 AUTO_INCREMENT의 현재 값을 가져올 때만 잠금이 걸렸다가 즉시 해제되기 때문에 성능상 문제가 될 때는 거의 없다.  

### REPLACE

REPLACE는 INSERT와 UPDATE의 기능을 묶은 쿼리와 같은 기능을 한다.  

```sql
REPLACE INTO employees VALUES (10001, 'Brandon', 'Lee');

REPLACE INTO employees 
SET emp_no=10001, first_name='Brandon', last_name='Lee';
```

REPLACE 문장에서 주의해야 할 점은 `중복된 레코드`에 대한 판정 기준이다.  

프라이머리 키나 유니크 키가 있다면 해당 키 모두에 중복된 값이 있는지 체크하고, 있다면 중복되는 레코드를 전부 삭제하고 넣으려는 데이터를 삽입한다.  

#### INSERT INTO ... ON DUPLICATE KEY UPDATE ...

REPLACE와 흡사하지만 중복된 레코드를 삭제하지 않고 UPDATE한다는 것이 유일한 차이다.  

```sql
INSERT INTO sampel_tbl (c1, c2) VALUES (1, 100) ON DUPLICATE KEY UPDATE c2=c2+100;
```

### LOAD DATA (LOCAL) INFILE

`SELECT INTO OUTFILE...` 쿼리에 대응하는 적재 쿼리다.  
CSV 파일 포맷의 데이터 파일을 읽어 MySQL 서버의 테이블로 적재한다.  
데이터 파일에서 각 칼럼의 값을 읽어서 바로 저장하기 때문에 INSERT 문장으로 저장하는 것보다 20배 빠르다고 알려져 있다.  

#### LOAD DATA INFILE의 성능 향상

LOAD DATA INFILE 명령으로 대량의 데이터를 적재할 때 다음 옵션들도 함께 사용하면 좋다.  


- AUTO-COMMIT

AUTO-COMMIT이 활성화된 상태에서는 레코드 단위로 INSERT가 실행될 때마다 COMMIT을 실행한다.  
이 작업은 매번 레코드 단위로 로그 파일의 디스크 동기화 작업을 발생시킨다.  
AUTO-COMMIT 모드를 비활성화하면 레코드가 INSERT 될 때마다 디스크에 플러시하는 작업을 피할 수 있다.  

```sql
SET autocommit = 0;
LOAD DATA ...
COMMIT;
SET autocommit = 1;
```

- UNIQUE INDEX

대량 적재 대상 테이블에 UNIQUE 인덱스가 있다면 매번 레코드 단위로 중복 체크가 발생한다.  
unique_checks 설정을 변경해 중복 체크를 건너뛰도록 설정할 수 있다.  
물론 적재되는 데이터의 중복이 없다는 것을 꼭 먼저 확인해야 한다.  

```sql
SET unique_checks = 0;
LOAD DATA ...
SET unique_checks = 1;
```

- FOREIGN KEY

데이터를 적재하는 테이블에 FOREIGN KEY가 있다면 매번 레코드의 INSERT 시점마다 FOREIGN KEY 값이 존재하는지 여부를 확인해야 한다.  
foreign_key_checks 설정을 변경하면 해당 무결성 체크를 수행하지 않고 바로 적재할 수 있다.  

```sql
SET foreign_key_checks = 0;
LOAD DATA ...
SET foreign_key_checks = 1;
```

