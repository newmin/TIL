# Real MySQL - 7. 쿼리 작성 및 최적화
#TIL/Database

---

## 개요

애플리케이션의 코드를 튜닝해서 성능을 2배 개선한다는 것은 쉽지 않은 일이지만, DBMS에서는 몇 십배, 몇 백배의 성능 향상이 흔한 일이다.   그만큼 SQL 쿼리를 튜닝하는 법을 아는 것이 중요하다.  
쿼리의 결과를 예측하는 것은 물론, 옵티마이저의 내부적인 처리 방식도 어느 정도 숙지할 필요가 있다.  



## 쿼리와 연관된 시스템 설정
### sql_mode

sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있는데, 몇 개만 보면 다음과 같다.

- STRICT_ALL_TABLES : 일반적인 MySQL에서는 저장하려는 값의 길이가 칼럼 길이를 넘어가더라도 경고만 발생시킨 후 초과한 부분을 자르고 저장한다. 이 옵션을 주면 경고가 아닌 에러를 발생시켜 칼럼 길이를 넘는 데이터를 저장하는 것을 막을 수 있다.
- STRICT_TRANS_TABLES : MySQL 서버는 칼럼 타입과 호환되지 않는 값을 저장하려고 할 때 최대한 변환해서 저장하려고 하나, 이 옵션을 주면 강제 변환하지 않고 에러를 발생시킨다.
- TRADITIONAL : 위 두 방법보다 조금 더 엄격한 방법으로 ANSI 표준 모드로 동작하도록 한다.
- ONLY_FULL_GROUP_BY : MySQL 쿼리에서는 GROUP BY절에 포함되지 않은 칼럼이라도 집합 함수 없이 SELECT나 HAVING절에 이용할 수 있도록 되어 있다. 사실 SQL 표준과는 거리가 있는 방식인데, 이 옵션은 이를 방지하도록 해준다.
- IGNORE_SPACE : 프로시저나 함수명과 괄호 사이에 공백이 들어가 있어도 무시해준다.
- ANSI : 위의 여러가지 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하도록 한다.

## 연산자와 내장 함수
### 연산자

- `<=>` 연산자는 Null-Safe 비교 연산자로  `=` 연산자와 같으며, NULL을 하나의 값으로 보고 비교할 수 있게 해준다. 즉, `NULL <=> NULL`은 true이다. 
- LIKE 연산자는 와일드카드 문자(%, _)가 검색어 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있고, 반대로 앞에 있다면 인덱스 레인지 스캔을 사용할 수 없다.
- BETWEEN과 IN은 비슷한 듯 보이지만 다르다. IN 연산자는 여러 개의 동등 비교(=)를 묶은 연산자라서 인덱스를 사용할 수 있다. 다만 IN 연산자에 사용할 상수들을 가져오기 위해 IN(subquery) 를 사용하는 것은 성능에 악영향을 줄 수 있다. 기대하는 대로 서브 쿼리가 먼저 실행되는 것이 아니라, 서브 쿼리의 외부가 먼저 실행되고 IN(subquery)가 체크 조건으로 사용되기 때문이다. 
- NOT IN은 부정형 비교라서 인덱스를 사용할 수 없다.

### 내장 함수

- 하나의 SQL에서 NOW()는 항상 같은 값이지만, SYSDATE()는 같은 SQL 안에서도 다른 값을 가질 수 있다.
	- SYSDATE()는 슬레이브 DB에서 안정적으로 복제되지 못하고, 해당 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용할 수 없다. (값이 매번 바뀌므로)
- BENCHMARK(반복횟수, 스칼라값을 반환하는 표현식) 함수는 쿼리의 성능을 알아볼 때 유용하게 쓰일 수 있는데, 주의할 점은 실제 반복횟수만큼 애플리케이션에서 실행하는 것과 해당 함수로 반복횟수만큼 실행하는 것에는 차이가 있다는 것이다. 벤치마크 함수는 딱 1번의 네트워크, 쿼리 파싱, 최적화가 일어나기 때문이다. 해당 함수는 같은 결과값을 가지는 두 개의 기능을 비교하는 데에 쓰면 좋다.
- COUNT()는 보통 COUNT(*)로 많이 쓰는데, *이라는 기호 때문에 굳이 특정 칼럼을 넣거나 COUNT(1) 같이 사용할 필요는 없다. 성능은 같다.
	- 보통 페이징 처리를 위해 많이 사용하는데, 대신 COUNT 쿼리에서 ORDER BY나 불필요한 LEFT JOIN 등이 걸려있는 것은 제거해야 한다. 인덱스를 제대로 사용하지 못하는 COUNT 쿼리는 많은 부하를 일으킬 수 있기 때문에 주의해야 한다.
		- 페이징 쿼리를 개발한 후 count를 위해 해당 쿼리를 그대로 복사해서 사용하다보니 자주 일어나는 실수이다.

## SELECT

### SELECT 각 절의 처리 순서

SELECT 쿼리의 결과를 예측하기 위해서는 처리 순서에 대한 이해가 필수적이다. 일반적으로는 다음 순서를 따른다.  

1. 드라이빙 테이블과 드리븐 테이블들에 대해 WHERE 적용 및 조인 실행
2. GROUP BY
3. DISTINCT
4. HAVING
5. ORDER BY
6. LIMIT

그리고 GROUP BY절이 없이 ORDER BY만 사용된 쿼리에서는 다음 순서를 따르기도 한다.  

1. 드라이빙 테이블 읽어서 ORDER BY 적용
2. 드리븐 테이블 WHERE 적용 및 조인 실행
3. LIMIT 적용

### WHERE 절의 인덱스 사용

인덱스를 사용하기 위한 기본적인 규칙은 **인덱스된 칼럼의 값 자체를 변경하지 않고 그대로 사용**해야 한다는 것이다.  

WHERE 조건이 인덱스를 사용할 수 있는 기준은 5장에서 보았듯이 범위 제한 조건과 체크 조건으로 나뉘는데, 범위 제한 조건으로 동등 비교 조건이나 IN으로 구성된 조건이 인덱스를 구성하는 칼럼과 순서대로 얼마나 일치하는가에 따라 달라진다.  

결국 WHERE 절에서는 각 조건이 명시된 순서는 중요하지 않고, 해당 칼럼에 대한 조건이 있는지 없는지가 중요하다.  

그리고 각 조건이 OR로 연결되면 비교해야 할 레코드가 더 늘어나기 때문에 풀 테이블 스캔을 사용하거나, 인덱스를 각각의 칼럼에 맞추어 사용하더라도 index_merge 방식으로 접근해야 해서 효율이 떨어질 수 있다. 인덱스를 효율적으로 이용할 수 있도록 OR 대신 AND로 조건을 주는 것이 좋다.  

### GROUP BY 절의 인덱스 사용

GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 WHERE 절처럼 범위 제한 조건이나 체크 조건 등을 고려할 필요는 없다.  

사용 조건은 다음과 같다.  

- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다.  
- 인덱스의 앞쪽부터 빠지는 칼럼 없이 사용해야 하며, 인덱스에 존재하지 않는 칼럼으로 GROUP BY를 사용해서도 안된다.  

여기서 조금 더 주의할 점은, WHERE 조건 절에 앞쪽, 예를 들어 COL1, COL2 가 동등 비교 조건으로 사용된다면, GROUP BY 절에는 COL1, COL2 가 빠지고 COL3 부터 사용해도 인덱스를 사용할 수 있다.  

즉 다음 두 쿼리는 같은 결과를 가져온다.  

```
... WHERE COL1 = '상수' ... GROUP BY COL2, COL3
... WHERE COL1 = '상수' ... GROUP BY COL1, COL2, COL3
```


### ORDER BY 절의 인덱스 사용

기본적으로 ORDER BY 는 GROUP BY 절의 사용 조건과 거의 비슷하다. 여기에 조건이 더 하나 추가되는데, 정렬되는 각 칼럼의 오름차순 혹은 내림차순 옵션이 인덱스와 같거나 정반대의 경우에만 사용할 수 있다는 것이다.  

즉 MySQL의 인덱스는 오름차순으로 정렬되어 있기 때문에, 모든 ORDER BY의 조건이 오름차순 혹은 내림차순 한 방향으로만 걸려있어야 한다.  

### WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용

다음 3가지 중 하나를 사용한다.  

- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 사용
	- WHERE, ORDER BY 절의 대상 칼럼이 모두 하나의 인덱스에 연속해서 포함되어 있을 때 사용 가능하다.
	- 가장 빠른 성능을 보인다.
- WHERE 절만 인덱스 이용
	- 인덱스를 통해 검색 후 Filesort를 통해 정렬을 수행한다.
	- WHERE 절의 조건에 일치하는 레코드 건수가 많지 않을 때 사용한다.
- ORDER BY 절만 인덱스 이용
	- ORDER BY 절의 순서대로 레코드를 읽으면서 WHERE 절을 하나씩 적용하는 방식이다.
	- 아주 많은 레코드를 조회해서 정렬해야 할 경우 이 방법을 사용하기도 한다.

### GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY 절의 칼럼과 ORDER BY 절의 칼럼이 순서와 내용이 모두 같아야 한다.  

**둘 중 하나라도 인덱스를 이용할 수 없을 때에는 둘다 인덱스를 사용하지 못한다**.  

### WHERE, ORDER BY, GROUP BY 절의 인덱스 사용

종합적으로 다음 3개의 질문으로 정리할 수 있다.  

```
1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?
```


### DISTINCT

DISTINCT에서 주의할 점은 **DISTINCT는 SELECT되는 레코드를 유니크하게 가져오는 것이지 칼럼 하나를 유니크하게 가져오는 것이 아니라는 것**이다.  

즉 다음 두 쿼리는 똑같이 (COL1 + COL2) 의 유니크 값을 가져온다. 괄호는 적용되지 않는다.

```
SELECT DISTINCT COL1, COL2 FROM test_table;
SELECT DISTINCT(COL1), COL2 FROM test_table;
```

하지만 집합 함수 내에서 사용된 DISTINCT 는 조금 다른데, 집합 함수의 인자 칼럼들 중에서 중복을 제거하고 남은 값들을 가져오게 된다.  

