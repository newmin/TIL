# Real MariaDB - 04. 실행 계획 분석
#TIL/Database/RealMariaDB

---

## 개요

### 쿼리 실행 절차

MariaDB 서버에서 쿼리가 실행되는 과정은 크게 3가지이다.  

- 사용자의 쿼리를 파싱해서 MariaDB 서버가 이해할 수 있는 `SQL 파스 트리`를 만든다.
	- "SQL 파싱"이라고 하며, MariaDB 서버의 "SQL 파서" 모듈이 처리한다.
- 파스 트리를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
	- "최적화 및 실행 계획 수립" 단계이며, MariaDB 서버의 "옵티마이저"에서 처리한다.
- 두 번째 단계에서 결정된 내용으로 스토리지 엔진으로부터 데이터를 가져온다.  
	- 스토리지 엔진이 데이터를 읽어오면, MariaDB 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.


### 옵티마이저의 종류

옵티마이저는 두 가지 방법으로 나눌 수 있는데, 요즘은 대부분의 RDBMS가  `비용 기반 최적화` 방법을 사용한다.  

- 규칙 기반 최적화
	- 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식이다.
	- 현재는 거의 지원되지 않거나 업데이트 되지 않는 방식이다.
- 비용 기반 최적화
	- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획 별 비용을 산출한다.

결국 비용 기반 최적화에서 가장 중요한 것은 `통계 정보`다.  

---

## 실행 계획 분석

EXPLAIN 키워드로 쿼리의 실행 계획을 확인할 수 있다.  
표의 각 라인은 쿼리 문장에서 사용된 테이블의 개수만큼 출력되고, 위쪽부터 (id 칼럼의 값이 작은 쪽부터) 가장 먼저 접근한 테이블이라고 보면 된다.  

각 칼럼의 내용을 하나씩 살펴보자.  

### id 칼럼

단위 SELECT 별로 부여되는 식별자 값이다.

### select_type 칼럼

- SIMPLE
	- UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
	- 반드시 하나만 존재한다.
- PRIMARY
	- UNION이나 서브 쿼리를 가지는 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리의 타입이다.
- UNION
	- UNION으로 결합하는 단위 쿼리 가운데 첫 번째를 제외한 두 번째 이후 쿼리의 타입이다.
	- UNION 첫 번째 단위 쿼리는 UNION의 결과를 담을 임시 테이블을 만들기 때문에 DERIVED 타입으로 표시된다.
- DEPENDENT UNION
	- DEPENDENT는 UNION, UNION ALL로 결합된 단위 쿼리가 외부에 의해 영향을 받는 것을 의미한다.  
- UNION RESULT
	- 임시 테이블로 생성한 UNION의 결과를 나타내는 라인의 타입이다.
	- 실제 단위 쿼리는 아니기 때문에 별도로 id값은 부여되지 않는다.
- SUBQUERY
	- FROM 절 이외에서 사용되는 서브 쿼리만을 의미한다.
- DEPENDENT SUBQUERY
	- 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우를 의미한다.
	- DEPENDENT 키워드는 외부 쿼리가 수행된 후 내부 쿼리가 수행되어야 하므로 처리 속도가 느리다.  
- DERIVED
	- 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블로 생성하는 것을 의미한다.
	- MariaDB 5.2(MySQL 5.5) 이하에서는 서브 쿼리가 FROM 절에 사용된 경우 항상 DERIVED를 만들었지만, 그 이후 버전부터는 FROM절의 서브 쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다.
	- 하지만 아무리 최적화가 일어나더라도 조인으로 해결할 수 있는 경우라면 서브 쿼리 보다는 조인으로 해결하는 것이 가장 좋다.
- UNCACHEABLE SUBQUERY
	- 보통은 조건이 똑같은 서브 쿼리가 실행될 때는 캐싱을 한다.
		- SUBQUERY는 외부 영향을 받지 않으므로 캐싱해서 필요할 때 사용한다.
		- DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 칼럼 단위로 캐싱해서 사용한다.
	- 서브 쿼리에 포함된 요소에 의해서 캐시 자체가 불가능한 경우에 해당 타입이 표시된다.
- UNCACHEABLE UNION
	- 위와 동일하게 캐시가 불가능한 경우의 UNION을 의미한다.
- MATERIALIZED
	- MariaDB 5.2 버전까지는 기준 테이블의 매 레코드마다 서브 쿼리를 읽어서 처리하는 형태였다.
	- 하지만 5.3 버전부터는 서브 쿼리의 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 기존 테이블을 조인하는 형태로 최적화한다.
- INSERT
	- MariaDB 10.0.5부터는 INSERT, UPDATE, DELETE 문장에 대해서도 실행 계획을 조회할 수 있게 되었다.

### table 칼럼

Table 칼럼에는 `<derived N>` , `<union M, N>` 과 같은 표현이 많은데, 이는 임시 테이블을 의미한다.  
또한 `<>` 안에 표시되는 숫자는 단위 SELECT 쿼리의 id를 의미한다.  

만약 두 테이블이 조인되는 경우, 실행 계획에 먼저 나온 테이블이 드라이빙 테이블이 되고, 후에 나온 테이블이 드리븐 테이블이 된다.  

select_type이 METERIALIZED인 실행 계획에서는 `<subquery N>` 과 같은 값이 table 필드에 표시되는데, 이는 서브 쿼리의 결과를 구체화(Materialization)해서 임시 테이블로 만들었다는 의미로 derived 와 같은 방식으로 해석하면 된다.  


### type 칼럼

type 칼럼은 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타내는 아주 중요한 지표다.  
방식이라 함은 인덱스를 사용해서 레코드를 읽었는지, 아니면 풀 테이블 스캔을 진행했는지를 의미한다.  

- system
	- 레코드가 0건 혹은 1건만 존재하는 테이블을 참조하는 형태의 접근 방법이다.
	- MYISAM, MEMORY 테이블에서만 사용된다.
- const
	- 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다.
- eq_ref
	- 여러 테이블이 조인하는 쿼리에서 나타난다.
	- 조인에서 처음 읽은 테이블의 컬럼 값을, 그 다음 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용하는 경우 두 번째 이후의 테이블에 eq_ref가 표시된다.
	- 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.  
- ref
	- 인덱스의 종류와 관계 없이 **동등 조건**으로 검색하는 경우이다.
	- 1건의 레코드만 반환한다는 보장이 없어도 된다.
- fulltext
	- 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법이다.  
- unique_subquery
	- WHERE 조건절에서 사용되는 IN(subquery)에서 중복되지 않은 유니크한 값만 반환할 경우이다.
- index_subquery
	- IN(subquery)에서 중복된 값을 반환할 수도 있는 경우에, 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 사용되는 접근 방법이다.
- range
	- `인덱스 레인지 스캔` 형태의 접근 방법이다.
	- 쿼리가 이 정도 실행 계획만 가져도 상당히 효율적으로 수행된다고 볼 수 있다. 보통 인덱스 레인지 스캔은 const, ref, range 세 가지의 접근 방법을 의미한다.
- index_merge
	- 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합하는 방식이다.
	- 경험 상 그렇게 빠르지는 않다고 한다.
- index
	- 가장 많이 오해하는 유형인데, `인덱스 풀 스캔`을 의미한다.
	- 풀 테이블 스캔보다야 낫겠지만, 인덱스를 효율적으로 사용하는 것이 아니기 때문에 좋은 접근 방법은 아니다. (LIMIT 가 같이 걸린다면 효율적일 수는 있다.)
- ALL
	- `풀 테이블 스캔`을 의미한다. 가장 비효율적인 방법이다.


### possible_keys 칼럼

이 칼럼은 실제 사용된 인덱스가 아닌 **사용할 법했던 인덱스의 목록**을 의미하므로 눈여겨 볼 필요는 없다.  


### key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.  

key 칼럼에는 보통 인덱스의 이름이 나타나고, PRIMARY가 표시되면 프라이머리 키가 사용된다는 의미이다.  
index_merge 실행 계획에서는 2개 이상의 인덱스가 사용되는데, 이 때는 두 개의 인덱스가 콤마(,)로 구분되어 표시된다.  

type이 ALL인 경우처럼 인덱스를 전혀 사용하지 못하면 Key 칼럼은 NULL로 표시된다.  


### key_len 칼럼

이 칼럼은 많은 사람들이 그냥 지나치지만 매우 중요한 정보 중 하나이다.  
다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지를 알려주는 값이다.  
정확히는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.  

col1 + col2 를 프라이머리 키로 가지고 있고, 두 프라이머리 키 칼럼 길이의 합이 16 바이트인 테이블의 다음 쿼리를 보자.  

```sql
EXPLAIN
SELECT * FROM sample_tbl
WHERE col1 = 'aaa' AND col2 <> 100; # col1 + col2 가 프라이머리 키
```

- MariaDB 5.0 이하
	- type은 ref, key_len은 16이 아닌 12로 표시되었다.
	- key_len에 표시되는 값은 인덱스를 이용해 범위를 제한하는 조건만 해당하기 때문이다.
- MariaDB 5.1 이상
	- type은 range로 바뀌었고, key_len이 16으로 표시되었다.
	- col2의 조건이 단순한 체크 조건임에도 불구하고 key_len에 같이 포함되어 계산됐다.
	- 결국 해당 버전 이상부터는 key_len 값으로 몇 바이트까지 범위 제한 조건으로 사용됐는지는 알 수 없다.

MariaDB 5.1부터는 조건이 범위 제한 조건이든 체크 조건이든 관계없이 인덱스를 이용할 수만 있으면 모두 스토리지 엔진으로 전달하도록 바뀌었다.  
이를 `컨디션 푸시 다운`이라고 한다.  


### ref 칼럼

참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여 준다.  
크게 신경쓰지 않아도 되는 칼럼이다.  


### rows 칼럼

실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여 준다.  
이 값은 반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지를 의미한다.  


### Extra 칼럼

칼럼 이름과는 달리 성능에 중요한 지표들이 꽤 나오므로 잘 알아두는 것이 좋다.  

- const row not found
	- const 접근 방식으로 테이블을 읽었지만 레코드가 1건도 없는 경우 표시된다.
- Distinct
	- 말그대로 중복 제거가 일어난다는 의미이다.
- Full scan on NULL key
	- "col1 IN (SELECT col2 FROM ...)" 과 같은 형태에서 col1이 NULL이 되는 경우 "NULL IN(SELECT col2 FROM ...)" 과 같은 형태가 된다.  이 때 서브쿼리의 결과가 1건 이상이면 최종 결과는 NULL, 서브쿼리의 결과가 0건이면 최종 결과는 FALSE가 나오게 된다.
	- 위 결과를 도출하기 위해 풀 테이블 스캔이 필요한데, 이 키워드는 col1이 NULL을 만날 경우 예비책으로 풀 테이블 스캔이 일어난다는 의미이다.
	- 만약 col1이 NOT NULL이면 해당 키워드는 표시되지 않을 것이다.
- Impossible HAVING
	- HAVING절의 조건을 만족하는 레코드가 없을 경우이다.
- Impossible WHERE
	- WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우이다.
- Impossible WHERE noticed after reading const tables
	- "SELECT * FROM sample_tbl WHERE id=0;" 과 같은 쿼리에서 실제로 id값이 0인지는 쿼리를 수행해봐야 알 수 있는 정보인데, 실행 계획 단계에서 해당 키워드가 나타난다.
	- 위 쿼리에서 프라이머리 키를 동등 조건으로 비교하기 때문에 const 접근 방식이 사용되었고, 이 때 옵티마이저가 실행 계획 단계에서 직접 쿼리의 일부를 수행한다는 것을 알 수 있다.
- No matching min/max row
	- MIN(), MAX()와 같은 집합 함수 쿼리의 조건절에 일치하는 레코드가 한 건도 없는 경우이다.
- no matching row in const table
	- 조인에 사용된 테이블에서 const 방식으로 접근할 때 일치하는 레코드가 없는 경우이다.
- No tables used
	- FROM절이 없는 쿼리 문장이나 "FROM DUAL" 형태의 쿼리에서 볼 수 있다.
- Not exists
	- A 테이블에는 존재하지만 B 테이블에는 존재하지 않는 값을 조회해야 하는 경우 NOT IN(subquery)나 NOT EXISTS 연산자를 주로 사용한다. 이를 `안티-조인`이라고 한다.
	- 하지만 안티-조인은 아우터 조인을 이용하면 빠른 성능을 낼 수 있다.
	- "SELECT * FROM tbl1 t1 LEFT JOIN tbl2 t2 ON t1.col = t2.col WHERE t1.col IS NULL;" 과 같은 형태로 변경할 수 있다.
	- 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서는 해당 키워드가 표시된다.
	- 이는 **이 쿼리를 NOT EXISTS 형태의 쿼리로 변환해서 처리한 것이 아님**에 주의하자. 그저 내부적인 최적화 방법의 이름이 "Not exists"인 것 뿐이다.






























