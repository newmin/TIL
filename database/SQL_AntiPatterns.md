# SQL AntiPatterns
#TIL/Database

---

## 2. 무단횡단

### 정의

다대다 관계를 위한 교차 테이블 생성을 피하기 위해 하나의 칼럼에 쉼표로 구분된 리스트를 보관하는 안티 패턴.  
(교차로를 피하고 무단횡단하는 것에 비유)  


### 문제점

- 정확한 칼럼 비교로 쿼리를 날릴 수 없고 늘 패턴 검색을 해야 한다.
- 집계 쿼리를 사용하기 어렵다.
- update 시 정렬을 보장할 수 없다.
- 해당 칼럼 타입에 대한 유효성을 보장할 수 없다. (숫자 id를 쉼표로 나열할 경우 문자열)
- 구분자 문자의 선택이 애매하다.
- 칼럼 길이의 제한으로 목록 길이 제한이 생긴다.


### 안티패턴이 합당한 경우

때로는 이런 반정규화가 성능을 향상시킬 수 있다.  
애플리케이션에서 쉼표로 구분된 문자열만을 필요로 하고, 개별 항목에는 별도로 접근할 필요가 없을 수도 있다.  


### 해결 방안

다대다 연관관계에는 양쪽 테이블의 FK를 가지는 교차 테이블을 생성한다.  

- A 테이블과 B 테이블을 교차하는 교차 테이블을 생성할 경우, 양쪽 테이블에서 교차 테이블에 조인을 걸어 필요한 속성을 모두 조회할 수 있다.  
	- 이는 인덱스를 훨씬 더 잘 이용한다.
- 집계 쿼리, insert / update / delete 사용이 용이해진다.
- 칼럼 타입의 유효성이 보장되고, 구분자나 길이 제한에 대한 고민이 없다.
- FK로 인해 생성된 인덱스를 활용할 수 있다.

---

## 3. 순진한 트리

### 정의

Comments (답글) 같은 엔티티처럼 `답글의 답글`이 무한정 달릴 수 있는 상황에서, 엔티티는 자기 자신을 참조하는 형태로 정의가 된다.  
이 때 단순하게 자신의 부모 id만을 가지고 있는 단순한 트리 형태를 말한다.  

### 문제점

- 어떤 답글 하나에서 모든 자식 답글을 조회할 수 없다.
	- 꼬리에 꼬리를 물고 조인을 걸면 가능하지만, 애초에 몇 depth가 최대 깊이인지 모르는 경우 이 문제는 불가능하게 된다.
- 노드의 추가, 이동은 간단하다. 하지만 삭제가 복잡하다.
	- 자식이 있는 노드일 경우, 해당 자식들을 전부 같이 삭제한다면 CASCADE 옵션으로 가능하겠지만, 그게 아니라 자식들을 부모 노드 등으로 이동해야 한다면 자식들의 update 작업 이후에 해당 노드를 삭제해야 한다는 번거로움이 있다.


### 안티패턴이 합당한 경우

depth 깊이가 1 ~ 2 depth 정도로 한정적이라면, 이 설계가 가장 좋을 수 있다.  
노드의 부모나 자식을 바로 조회할 수 있고, 새로운 노드의 추가 작업도 쉽기 때문이다.  


### 해결 방안

세 가지 방안이 있다.  

- 경로 열거
	- 문자열 타입의 '경로(path)'라는 칼럼을 놓고, 루트부터 해당 노드까지의 경로를 '1/4/6/7/'과 같은 식으로 저장한다.
	- 2장의 '무단횡단'에서와 같은 문제점이 존재한다.
- 중첩 집합
	- 각 노드의 왼쪽, 오른쪽 포인터를 숫자로 지칭한다. 이 때 수는 루트의 왼쪽 포인터부터 차례로 '깊이 우선 탐색' 방식에 따라 부여된다.
	- 특정 노드의 모든 자식과 모든 부모를 해당 노드의 양쪽 포인터에 부여된 숫자 사이의 값을 비교하는 쿼리로 조회할 수 있다.
	- 노드의 추가, 이동 조작이 복잡하다. 노드를 빈번하게 추가하는 모델에서는 좋은 해결 방안이 아니다.
- 클로저 테이블
	- 트리의 모든 경로를 별도의 테이블에 조상-후손 관계로 저장한다.
		- 1-2-3 순으로 부모 자식 관계를 갖고 있다면, 1-1, 1-2, 1-3, 2-2, 2-3, 3-3 과 같은 식으로 저장한다.
	- 조회나 관계의 수정이 용이하다. 노드 관계를 삭제한다고 노드 자체가 사라지는 것도 아니다.
	- '조상과 후손 간의 길이'를 저장하는 칼럼을 하나 더 만들어 놓는다면 조회 방식이 더 간편해질 수 있다.

---

