# SQL AntiPatterns
#TIL/Database

---

## 2. 무단횡단

### 정의

다대다 관계를 위한 교차 테이블 생성을 피하기 위해 하나의 칼럼에 쉼표로 구분된 리스트를 보관하는 안티 패턴.  
(교차로를 피하고 무단횡단하는 것에 비유)  


### 문제점

- 정확한 칼럼 비교로 쿼리를 날릴 수 없고 늘 패턴 검색을 해야 한다.
- 집계 쿼리를 사용하기 어렵다.
- update 시 정렬을 보장할 수 없다.
- 해당 칼럼 타입에 대한 유효성을 보장할 수 없다. (숫자 id를 쉼표로 나열할 경우 문자열)
- 구분자 문자의 선택이 애매하다.
- 칼럼 길이의 제한으로 목록 길이 제한이 생긴다.


### 안티패턴이 합당한 경우

때로는 이런 반정규화가 성능을 향상시킬 수 있다.  
애플리케이션에서 쉼표로 구분된 문자열만을 필요로 하고, 개별 항목에는 별도로 접근할 필요가 없을 수도 있다.  


### 해결 방안

다대다 연관관계에는 양쪽 테이블의 FK를 가지는 교차 테이블을 생성한다.  

- A 테이블과 B 테이블을 교차하는 교차 테이블을 생성할 경우, 양쪽 테이블에서 교차 테이블에 조인을 걸어 필요한 속성을 모두 조회할 수 있다.  
	- 이는 인덱스를 훨씬 더 잘 이용한다.
- 집계 쿼리, insert / update / delete 사용이 용이해진다.
- 칼럼 타입의 유효성이 보장되고, 구분자나 길이 제한에 대한 고민이 없다.
- FK로 인해 생성된 인덱스를 활용할 수 있다.

---

## 3. 순진한 트리

### 정의

Comments (답글) 같은 엔티티처럼 `답글의 답글`이 무한정 달릴 수 있는 상황에서, 엔티티는 자기 자신을 참조하는 형태로 정의가 된다.  
이 때 단순하게 자신의 부모 id만을 가지고 있는 단순한 트리 형태를 말한다.  

### 문제점

- 어떤 답글 하나에서 모든 자식 답글을 조회할 수 없다.
	- 꼬리에 꼬리를 물고 조인을 걸면 가능하지만, 애초에 몇 depth가 최대 깊이인지 모르는 경우 이 문제는 불가능하게 된다.
- 노드의 추가, 이동은 간단하다. 하지만 삭제가 복잡하다.
	- 자식이 있는 노드일 경우, 해당 자식들을 전부 같이 삭제한다면 CASCADE 옵션으로 가능하겠지만, 그게 아니라 자식들을 부모 노드 등으로 이동해야 한다면 자식들의 update 작업 이후에 해당 노드를 삭제해야 한다는 번거로움이 있다.


### 안티패턴이 합당한 경우

depth 깊이가 1 ~ 2 depth 정도로 한정적이라면, 이 설계가 가장 좋을 수 있다.  
노드의 부모나 자식을 바로 조회할 수 있고, 새로운 노드의 추가 작업도 쉽기 때문이다.  


### 해결 방안

세 가지 방안이 있다.  

- 경로 열거
	- 문자열 타입의 '경로(path)'라는 칼럼을 놓고, 루트부터 해당 노드까지의 경로를 '1/4/6/7/'과 같은 식으로 저장한다.
	- 2장의 '무단횡단'에서와 같은 문제점이 존재한다.
- 중첩 집합
	- 각 노드의 왼쪽, 오른쪽 포인터를 숫자로 지칭한다. 이 때 수는 루트의 왼쪽 포인터부터 차례로 '깊이 우선 탐색' 방식에 따라 부여된다.
	- 특정 노드의 모든 자식과 모든 부모를 해당 노드의 양쪽 포인터에 부여된 숫자 사이의 값을 비교하는 쿼리로 조회할 수 있다.
	- 노드의 추가, 이동 조작이 복잡하다. 노드를 빈번하게 추가하는 모델에서는 좋은 해결 방안이 아니다.
- 클로저 테이블
	- 트리의 모든 경로를 별도의 테이블에 조상-후손 관계로 저장한다.
		- 1-2-3 순으로 부모 자식 관계를 갖고 있다면, 1-1, 1-2, 1-3, 2-2, 2-3, 3-3 과 같은 식으로 저장한다.
	- 조회나 관계의 수정이 용이하다. 노드 관계를 삭제한다고 노드 자체가 사라지는 것도 아니다.
	- '조상과 후손 간의 길이'를 저장하는 칼럼을 하나 더 만들어 놓는다면 조회 방식이 더 간편해질 수 있다.

---

## 4. 아이디가 필요해

### 정의

PK 칼럼을 지정하지 않는 경우, 혹은 관용적으로 "id"라는 이름을 지어놓고 자동 생성하는 것.  

### 문제점

- id 칼럼이 실제 PK로 활용되지 못하고 더 실용적인 구분자 칼럼에 UNIQUE 제약조건이 걸려 있는 경우
- 교차 테이블에서 양쪽 테이블의 FK 조합이 유일하다는 것을 보장해줄 수 없다.
- "id"라는 칼럼의 이름이 너무 모호하다. USING 키워드를 쓸 때도 모호한 쿼리가 될 수 있다.

### 안티패턴이 합당한 경우

지나치게 긴 자연키를 대체하는 경우

### 해결 방안

- PK에 의미 있는 이름을 선택한다.
- 자연키와 복합키를 포용해서 사용한다.

> 이 파트의 내용에는 전부 동의하지 않는다.  
> 유일성을 100% 보장할 수 없는 복합키의 사용보다는 자동 생성되는 정수 타입의 id가 더 합당하다고 생각한다.  

---

## 5. 키가 없는 엔트리

### 정의

FK 제약 조건을 생략하고 적용하지 않는 것  
이유는 다음과 같다고 생각하기 때문이다.  

- FK에 걸리는 인덱스 때문에 성능에 영향을 받는다고 믿는다.

### 문제점

- insert / delete 시에 항상 참조 테이블에 존재하는 값인지를 애플리케이션에서 확인해야 한다.
- 깨진 참조가 발생하거나, 발생을 탐지하는 행위를 수시로 해야한다.  
- 여러 테이블을 업데이트하는 경우, 관련된 참조 테이블도 순서를 고려해서 업데이트 해야한다.

### 안티패턴이 합당한 경우

MySQL의 MyISAM 스토리지 엔진과 같은 데이터베이스를 사용한다면 애플리케이션에서 보완하는 수밖에 없다.  

### 해결 방안

FK를 사용하면 애플리케이션에서 불필요한 코드를 작성하지 않아도 된다.  
CASCADE 기능도 사용할 수 있다.  

> 요즘은 FK에 대해서 어떻게 생각하고 있는지 조사가 필요하다.

---

## 6. 엔터티-속성-값

### 정의

부모 테이블 한 개- 상속받은 자식 테이블 다수의 관계에서 모든 자식 테이블의 속성을 표현하기 위해 범용 속성 테이블을 사용하는 것이다.  
`엔티티-속성-값(Entity-Attribute-Value, EAV)`이라고 부른다.  

예를 들어 Issues라는 테이블에는 id만 PK로 두고, IssueAttributes라는 속성 테이블을 정의해 속성이름-속성값 으로 정의된 행을 두는 것이다.  
본래라면 하나의 엔티티 레코드에 전부 표현되었을 속성들이 확장성에 유연하다는 이유로 속성 테이블에 여러 행으로 표현된다.  

### 문제점

- 단순한 속성을 조회하려고 해도, 문자열 비교로 속성이름을 조회하는 쿼리를 짜야 한다.  
- NOT NULL 같은 필수 속성 강제 조건을 사용할 수 없다.  
- 심지어 날짜형 같은 데이터나 참조 정합성 제약조건이 걸린 데이터도 validation을 할 수 없게 된다.
- 하나의 레코드 전체를 조회하려면 그 수만큼의 조인을 걸어야 한다.

### 안티패턴이 합당한 경우

없다.  
비관계형 데이터 관리가 필요하다면 비관계형 기술을 사용하자. (MongoDB, Redis 등)  

### 해결 방안

서브타입 모델링이라고 하는데, 다음과 같은 방법들이 있다.  

- **단일 테이블 상속 (Single Table Inheritance)**
	- 관련된 모든 타입을 하나의 테이블에 저장하고, 각 타입에 있는 모든 속성을 별도의 칼럼으로 가지게 하는 것이다.
	- 해당 레코드가 어떤 서브타입인지 표시하는 메타데이터 칼럼이 필요하다.
	- 새로운 서브타입이 생기면, 해당 테이블에 서브타입에 대한 새로운 속성 칼럼을 추가해야 한다.
		- 어느 속성이 어느 서브타입에 속하는지에 대한 메타데이터가 존재하지 않는다.
	- 서브타입 개수가 적고 특정 서브타입에 속하는 속성 개수가 적을 때 사용한다.
- **구체 테이블 상속 (Concrete Table Inheritance)**
	- 서브타입별로 별도의 테이블을 만들고, 공통속성도 전부 포함하도록 하는 것이다.
	- 단일 테이블 상속보다 좋은 점은, 특정 서브타입을 저장할 때 해당 서브타입에 적용되지 않는 속성은 저장할 수 없게 한다는 것이다.
	- 단일 테이블 상속에서처럼 하나의 레코드가 어떤 서브타입인지 나타내는 메타데이터 칼럼이 필요하지 않다.
	- 단, 어떤 칼럼들이 공통 속성인지 알 수가 없다는 단점이 있다.
		- 히스토리를 모르는 개발자가 본다면, 각 서브타입 간 논리적 관계가 있어서 칼럼이 비슷한 것인지 아니면 우연의 일치인 것인지 분간할 수가 없다.
	- 모든 서브타입을 한꺼번에 조회할 필요가 거의 없는 경우에 사용한다.
- **클래스 테이블 상속 (Class Table Inheritance)**
	- 테이블을 객체지향 클래스인 것처럼 생각해 상속을 흉내 내는 것이다.
	- 공통 속성을 가지는 베이스 테이블을 두고, 각 서브타입 테이블이 베이스 테이블의 PK를 서브타입 테이블의 PK 및 FK로 참조하는 것이다.
		- 이 관계로 인해 베이스 - 서브타입 간에 일대일 관계가 강제된다.
	- 이 설계는 베이스 타입에 있는 속성만으로도 모든 서브타입을 효율적으로 검색할 수 있도록 한다.
	- 모든 서브타입에 대한 조회가 많고 공통칼럼을 참조하는 경우가 많다면 이 설계가 가장 적합하다.

---

## 7. 다형성 연관

### 정의

이중 목적의 FK를 사용하는 것이다.  
예를 들어 Comments 테이블이 다대일로 참조하는 테이블이 Bugs 테이블과 FeatureRequests 테이블 모두를 참조하고 있는 경우이다.  
댓글은 어디에든 달릴 수 있으니 버그 항목과 기능요구사항 항목 전부에 관계를 맺는 형식이다.  

따라서 어떤 테이블의 참조를 갖고 있는지 타입(부모 테이블 이름)을 명시하는 메타데이터 컬럼이 필요하다.  

### 문제점

- 참조 테이블에 해당하는 id 컬럼에 FK를 걸 수가 없다.  
	- `Comments.issue_id`가 `Bugs.issue_id`일수도 있고 `FeatureRequests.issue_id`일수도 있기 때문이다.
	- FK는 하나의 테이블만 참조할 수 있다.
- 조회 시 항상 타입 조건을 넣어서 조회해야만 한다.  
- 또한 아우터 조인을 통한 조회 결과에서 다른 부모에 해당하지 않는 부모 id 칼럼은 NULL로 표기될 것이다.

> 6장의 EAV 패턴과 유사하다.
> EAV에서 속성 이름을 문자열로 저장하는 것과 부모 테이블 이름을 타입 칼럼에 저장하는 것 모두 메타데이터이다.  
> 이를 '데이터와 메타데이터 혼용'이라 부른다.

### 안티패턴이 합당한 경우

Hibernate 같은 ORM과 같이, 참조 정합성 유지를 위한 애플리케이션 로직을 프레임워크 단에서 캡슐화해서 보장해준다면 허용될 수 있다.  

### 해결 방안

모든 테이블 관계에는 참조하는 테이블 하나, 참조되는 테이블 하나만 있도록 설계한다.  

- 각 부모에 대해 별도의 교차 테이블을 생성한다.
	- BugsComments, FeaturesComments 와 같은 교차 테이블
	- 교차테이블을 중심으로 조인하면 댓글을 조회하거나 Issue를 조회할 경우 모두 편해진다.
- 공통인 수퍼테이블을 생성한다.
	- Bugs와 FeatureRequests의 공통속성을 가진 부모 Issues 테이블을 만들고, Comments가 Issues와 다대일 관계를 맺도록 한다.
	- 이렇게 되면 Comments가 어느 한쪽에 포함됨을 보장하면서도, 조회 시에는 각 서브타입과 Comments를 직접 조인하면 된다.
	- Issues와 같은 조상 테이블로 인해 FK를 사용해 정합성을 강제할 수 있다.

---

## 8. 다중 칼럼 속성

### 정의

어떤 글에 중복해서 달 수 있는 `태그` 같이, 한 테이블에 들어가야 할 것 같은 속성인데 여러 개를 저장해야하는 경우다.  
이 때 같은 속성임에도 불구하고 칼럼을 여러 개 미리 만들어 놓는 경우다. (태그 칼럼 세 개)  

### 문제점

보통의 경우 null 값인 경우가 많다.  

- 값을 검색할 때 어느 칼럼에 들어가 있는지 모르니 모든 칼럼을 조건절에 넣어야 한다.  
- 값의 추가와 삭제 시에도 해당 칼럼에 값이 들어있는지를 먼저 조회해서 체크해야 한다.
- 여러 칼럼에 중복값이 들어가는 것을 막을 수 없다.
- 만들어놓은 칼럼보다 더 많은 칼럼이 필요한 경우도 생길 수 있다.

### 안티패턴이 합당한 경우

각 칼럼이 같은 속성일지라도 논리적으로 명확하게 다른 칼럼으로 사용된다면 허용될 수 있다.  

### 해결 방안

종속 테이블을 생성해야 한다.  
칼럼을 늘려서 저장하는 것이 아니라 별도의 테이블에 행으로 저장하면 모든 문제가 해결된다.  

---


## 9. 메타데이터 트리블

### 정의

시간 별로 관리해야 하는 데이터가 다르고, 계속 늘어나는 경우를 말한다.  
예를 들어 연도별 매출 같은 경우를 여러 칼럼을 만들어서 관리하는 경우다.  

두 가지 형태의 안티패턴이 존재한다.  

- 많은 행을 가진 큰 테이블을 여러 개의 작은 테이블로 분리하고, 각 테이블의 이름을 다른 속성을 기준으로 해서 짓는다.
- 하나의 칼럼을 여러 개의 칼럼으로 분리하고, 칼럼의 이름을 다른 속성을 기준으로 해서 짓는다.

> 트리블은 스타트랙에 나오는 털복숭이 애완동물이다.  
> 번식력이 강해 제어하는 것이 고민이었다고 한다.  

### 문제점

- 시간이 갈수록 테이블이 점점 늘어나거나, 칼럼을 매번 추가해야 한다.
- 각각의 테이블, 칼럼에 데이터가 정확하게 들어갔는지 정합성을 보장하기 힘들다.
- 데이터를 보정할 때도 update문 대신 삭제-추가 과정을 거쳐야 할 수도 있다.
- 유일성을 보장할 수 없다.
- 종속 테이블이 존재하는 경우, 부모 테이블이 여러 개라서 FK를 지정할 수 없다.

### 안티패턴이 합당한 경우

오래된 데이터의 사용 빈도가 매우 낮아 별도 보관하는 경우가 있다.  
데이터 사이즈를 줄이면 성능 상으로도 훨씬 좋다.  

### 해결 방안

파티션과 정규화를 진행해야 한다.  

- 수평 분할
	- 행을 여러 파티션으로 분리하는 방법이다.
	- 클라이언트 입장에서는 하나의 논리적인 테이블이지만, 실제로는 데이터베이스에서 특정 속성을 기준으로 여러 테이블을 알아서 관리해준다.
- 수직 분할
	- 수평 분할이 테이블을 행으로 나누는 반면, 수직 분할은 칼럼으로 테이블을 나눈다.
	- BLOB, TEXT 같이 사이즈가 큰 칼럼을 분리하고, 해당 칼럼이 필요없는 조회 시에 칼럼을 참조하지 않는 조회를 하면 훨씬 효율적으로 접근할 수 있다.
- 메타데이터 트리블 칼럼 고치기
	- 8장에서와 비슷하게 종속 테이블을 만들어 관리할 수 있다.
	- 연도별 칼럼 대신 별도의 테이블을 만들고 행으로 관리하는 방식이다.

---












