## 아이템 10. equals는 일반 규약을 지켜 재정의하라

equals는 다음의 상황에서는 재정의하지 않는 것이 최선이다.

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 `논리적 동치성`을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

equals를 재정의해야 할 때는, 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.  
주로 값 클래스들이 여기 해당한다.  

값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다.  
이런 클래스에서는 논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다.  
Object의 equals가 논리적 동치성까지 확인해준다고 볼 수 있다.  

equals 메서드를 재정의할 때는 반드시 다음 규약을 따라야 한다.  

- 반사성(reflexivity)
    - null이 아닌 모든 참조값 x에 대해, x.equals(x)는 true다.
- 대칭성(symmetry)
    - null이 아닌 모든 참조값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성(transivity)
    - null이 아닌 모든 참조값 x, y, z에 대해, x.equals(y)가 true고 y.equals(z)도 true면 x.equals(z)도 true다.
- 일관성(consistency)
    - null이 아닌 모든 참조값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null 아님
    - null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false다.

양질의 equals 메서드 구현 방법을 정리하면 다음과 같다.  

- `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
- `instanceof` 연산자로 입력이 올바른 타입인지 확인한다.
    - instanceof는 두 번째 피연산자와 무관하게 첫 번째 피연산자가 null이면 false를 반환하므로, 앞서서 null 검사를 명시적으로 하지 않아도 된다.
- 입력을 올바른 타입으로 형변환한다.
- 입력 객체와 자기 자신의 대응되는 `핵심` 필드들이 모두 일치하는지 하나씩 검사한다.

참고로 어떤 필드를 먼저 비교하느냐에 따라 equals의 성능을 좌우하기도 한다.  
고로 다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교하는 것이 좋다.  

- equals를 재정의할 땐 hashCode도 반드시 재정의하자. (아이템 11)
- 너무 복잡하게 해결하려 들지 말자.
    - 필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
    - `@Override` 어노테이션을 명시하여 의미 없는 오버로딩을 막자.

## 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.  
다음은 Object 명세의 규약이다.  

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.
단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.
단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다.  
즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.  

좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.  
이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.  

책에서 소개하는 최적의 구체적인 hashCode 구현 방법이 있지만 생략하고, 성능은 조금 아쉽지만 한줄짜리 hashCode는 다음과 같다. (IDE에서도 제공)  

```java
@Override
public int hashCode() {
    return Objects.hash(field1, field2, field3);
}
```

## 아이템 12. toString을 항상 재정의하라

toString의 일반 규약에 따르면 `간결하면서 사람이 읽기 쉬운 형태의 유익한 정보` 를 반환해야 한다.  
toString를 잘 구현한 클래스는 디버깅하기가 쉽다.  
실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.  

단점도 있다. 포맷을 한번 명시하면 평생 그 포맷에 얽매이게 된다.  
포맷을 명시하든 아니든 의도는 항상 명확하게 밝혀야 하고, toString이 반환한 값에 포함된 정보를 얻을 수 있는 API는 별도로 제공하자.  
(사용자가 toString을 파싱하여 정보를 얻는 것은 말이 안된다.)  

참고로 정적 클래스는 toString을 제공할 이유가 없고, 열거 타입은 이미 자바가 toString을 제공하니 따로 재정의할 필요는 없다.  
다만 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 재정의하는 것이 좋다.

## 아이템 13. clone 재정의는 주의해서 진행하라

Cloneable은 복제해도 되는 클래스임을 명시하는 인터페이스지만, 아쉽게도 의도한 목적을 제대로 이루지 못했다.  
가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는 데 있다.  
그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출할 수 없다.  

메서드 하나 없는 Cloneable 인터페이스는 대체 무슨 일을 할까?  
놀랍게도 Object의 protected 메서드인 clone의 동작 방식을 결정한다.  
Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 해당 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다.  
(인터페이스를 상당히 이례적으로 사용한 예이므로 따라 하지는 말자.)  

Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.  
하지만 clone 메서드의 일반 규약은 허술하다.  

clone을 구현하는 객체의 모든 필드가 기본 타입이거나 불변 객체를 참조한다면, clone 메서드에서는 super.clone만 호출하고 해당 타입으로 반환해주면 되니 문제될 것이 없다.  
클래스가 가변 객체를 참조하는 순간 재앙이다.  
상위 클래스의 참조값을 그대로 참조하기 때문에, 하위 클래스에서 상위 클래스의 필드에 영향을 미치게 되어 불변식을 해치게 된다.  

clone 메서드는 사실상 생성자와 같은 효과를 낸다.  
즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.  

가변 객체를 제대로 clone하려면 가변 필드의 clone을 재귀적으로 호출해주는 방법이 있긴 하다.  
추가적으로 깊은 복사를 수행하도록 구성해줄 수도 있다.  
하지만 해당 필드가 final이었다면 이 방법도 작동하지 않는다.  
이는 근본적인 문제로, 직렬화와 마찬가지로 Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다.  
심지어 깊은 복사를 위해 재귀를 사용하다보면 스택 오버플로를 일으킬 위험도 존재한다.  

복잡한 가변 객체를 복제하는 마지막 방법은 super.clone 호출 후 얻은 객체를 초기 상태로 설정한 다음, 원본 객체의 상태를 고수준 API를 사용하여 업데이트하는 것이다.  
아무래도 간단하고 우아한 방법이지만, 저수준에서보다는 느릴 수밖에 없다.  

기억할 게 하나 더 있는데, Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화해줘야 한다.  

### 요약

Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다.  
이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다.  

가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다. (깊은 복사)  
보통 재귀적으로 구현하지만, 늘 최선인 것은 아니기에 반복문으로 구성할 수도 있다.  
기본 타입 필드와 불변 객체 참조만 갖는 클래스라면 아무 필드도 수정할 필요가 없다.  

### 대안

Cloneable을 이미 구현한 클래스를 확장한다면 어쩔 수 없지만, 그렇지 않다면 `복사 생성자`와 `복사 팩터리` 라는 더 나은 객체 복사 방식을 제공할 수 있다.  
생성자를 사용하지 않는 위험한 방법, 엉성한 규약과도 무관하고, final 용법과도 충돌하지 않으며, 불필요한 체크 예외도 없고 형변환도 필요하지 않다.  
심지어 복사 생성자와 복사 팩터리는 **해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수** 있다.

## 아이템 14. Comparable을 구현할지 고려하라

compareTo는 Object의 메서드가 아니다.  
compareTo는 Object의 equals와 같은 성격을 가지고 있고, 추가적으로 **순서까지 비교할 수 있으며, 제네릭**하다.  
Comparable을 구현했다는 것은 해당 클래스의 인스턴스들에는 자연적인 순서(natural order)가 있음을 뜻한다.  
Comparable을 구현하면 이 인터페이스를 활용하는 수많은 제네릭 알고리즘과 컬렉션의 힘을 누릴 수 있다.  
그러므로 순서가 명확한 값 클래스를 작성한다면 Comparable을 꼭 구현하자.  

compareTo 메서드의 일반 규약은 equals와 비슷하게 반사성, 대칭성, 추이성을 따른다.  
추가적으로 필수 규약은 아니지만 지키면 좋은 규약은 compareTo 메서드로 수행한 동치성 테스트의 결과가 equals 메서드와 같아야 한다는 것이다.  
이를 잘 지키면 compareTo로 줄지은 순서와 equals의 결과가 일관되게 된다.  
(놀랍게도 정렬된 컬렉션은 동치성을 비교할 때 equals 대신 compareTo를 사용하기 때문에, 두 메서드가 일관되지 않다면 약간의 문제가 생길 수 있다.)  

Comparable은 타입을 인수로 받는 제네릭 인터페이스이므로 컴파일 타임에 인수 타입이 정해진다.  
특별히 타입을 체크할 필요가 없다는 뜻이다.  

객체 참조 필드를 비교할 때는 compareTo 메서드를 재귀적으로 호출한다.  
Comparable을 구현하지 않은 필드나 표준이 아닌 방식으로 비교해야 한다면 Comparator(비교자)를 대신 사용한다.  
비교자는 직접 만들거나 자바가 제공하는 것 중에 골라 쓰면 된다.  

compareTo에서 관계 연산자인 `<`, `>` 를 사용하는 것은 좋지 않다.  
대신 박싱된 기본 타입에 있는 compare 메서드를 활용하는 것이 좋다.  

compareTo에서는 가장 핵심적인 필드부터 비교해나가자.  
비교 결과가 0이 아니라면 순서가 결정되므로 거기서 끝이다.  

Java 8 에서는 Comparator 인터페이스가 연쇄적으로 비교자를 생성할 수 있게 되었다.  

```java
private static final Comparator<PhoneNumber> COMPARATOR = 
        comparingInt((PhoneNumber pn) -> pn.areaCode)
                .thenComparingInt(pn -> pn.prefix)
                .thenComparingInt(pn -> pn.lineNum);
```

그리고 이따금 `값의 차` 를 기준으로 첫 번째 값이 두 번째 값보다 작으면 음수를, 두 값이 같으면 0을, 첫 번째 값이 크면 양수를 반환하는 compareTo나 compart 메서드가 있는데, 이 방식은 사용하면 안된다.  
정수 오버플로를 일으키거나 부동소수점 계산 방식(IEEE 754)에 따른 오류를 낼 수 있기 때문이다.  

```java
public int compare(Object o1, Object o2) {
    return o1.hashCode() = o2.hashCode();
}
```

대신 다음 두 가지 방법 중 하나를 사용하자.  

```java
Integer.compare(o1.hashCode(), o2.hashCode());
Comparator.comparingInt(o -> o.hashCode());
```
