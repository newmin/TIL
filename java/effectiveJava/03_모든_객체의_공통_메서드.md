## 아이템 10. equals는 일반 규약을 지켜 재정의하라

equals는 다음의 상황에서는 재정의하지 않는 것이 최선이다.

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 `논리적 동치성`을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

equals를 재정의해야 할 때는, 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다.  
주로 값 클래스들이 여기 해당한다.  

값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다.  
이런 클래스에서는 논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다.  
Object의 equals가 논리적 동치성까지 확인해준다고 볼 수 있다.  

equals 메서드를 재정의할 때는 반드시 다음 규약을 따라야 한다.  

- 반사성(reflexivity)
    - null이 아닌 모든 참조값 x에 대해, x.equals(x)는 true다.
- 대칭성(symmetry)
    - null이 아닌 모든 참조값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성(transivity)
    - null이 아닌 모든 참조값 x, y, z에 대해, x.equals(y)가 true고 y.equals(z)도 true면 x.equals(z)도 true다.
- 일관성(consistency)
    - null이 아닌 모든 참조값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null 아님
    - null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false다.

양질의 equals 메서드 구현 방법을 정리하면 다음과 같다.  

- `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
- `instanceof` 연산자로 입력이 올바른 타입인지 확인한다.
    - instanceof는 두 번째 피연산자와 무관하게 첫 번째 피연산자가 null이면 false를 반환하므로, 앞서서 null 검사를 명시적으로 하지 않아도 된다.
- 입력을 올바른 타입으로 형변환한다.
- 입력 객체와 자기 자신의 대응되는 `핵심` 필드들이 모두 일치하는지 하나씩 검사한다.

참고로 어떤 필드를 먼저 비교하느냐에 따라 equals의 성능을 좌우하기도 한다.  
고로 다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교하는 것이 좋다.  

- equals를 재정의할 땐 hashCode도 반드시 재정의하자. (아이템 11)
- 너무 복잡하게 해결하려 들지 말자.
    - 필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
    - `@Override` 어노테이션을 명시하여 의미 없는 오버로딩을 막자.
