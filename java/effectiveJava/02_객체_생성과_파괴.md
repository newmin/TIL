# 02. 객체 생성과 파괴
#TIL/java/effectiveJava

---

## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

정적 팩터리 메서드의 장점은 다음과 같다.  

- 이름을 가질 수 있다.
	- 단순히 public 생성자로 생성하는 방법에 비해 구체적인 의미를 부여해줄 수 있다.
	- 한 클래스에 메소드 시그니처 타입이 같거나 유사한 경우가 존재한다면 정적 팩터리 메서드를 고려하자.
- 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
	- `인스턴스 통제 클래스`라고 한다.
		- 싱글턴 가능, 인스턴스화 불가로 만들 수 있음, 불변 값 클래스에서 동치인 인스턴스가 1개뿐임을 보장할 수 있음
	- 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.
- 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
	- API를 만들 때 이 유연성을 이용하면 구현체를 공개하지 않아도 해당 객체를 반환할 수 있다.
	- 사용하는 프로그래머 입장에서는 적은 수의 API만 습득해도 되고, 구현체를 알 필요가 없다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
	- 위와 마찬가지로 반환 타입의 하위 타입이면 어떤 구현체든지 반환할 수 있다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
	- 위와 마찬가지로 인터페이스를 구현하는 구현체가 나중에 사용자의 등록으로 생성되는 클래스일 경우 (프레임워크 입장에서), 해당 코드를 작성하는 당시에는 구현체를 몰라도 가능하다.

단점은 다음과 같다.  

- 상속을 하려면 public이나 protected 생성자가 필요하기 때문에 정적 팩토리 메서드만으로는 하위 클래스를 만들 수 없다.
	- 하지만 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 장점으로 볼 수도 있다.
- 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.  
	- 관용적인 메서드명은 아래에 정리했다.

관용적인 정적 팩토리 메서드명은 다음과 같다.  

- from
	- 매개변수를 하나 받은 형변환 메서드
- of
	- 여러 매개변수를 받는 집계 메서드
- valueOf
	- from과 of의 더 자세한 버전
- instance, getInstance
	- 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
- create, newInstance
	- 매번 새로운 인스턴스를 생성함을 보장한다.
- getType
	- 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
	- `FileStore fs = Files.getFileStore(path);`
- newType
	- 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. (매번 새로운 인스턴스임을 보장)  
	- `BufferedReader br = Files.newBufferedReader(path);`
- type
	- getType, newType의 간결한 버전

---

## 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

정적 팩터리 메서드와 일반 public 생성자 간에는 동일한 제약이 하나 있다.  
파라미터가 많을 때 대응이 힘들다는 점이다.  

첫 번째 방법은 `점층적 생성자 패턴(telescoping constructor pattern)` 이다.  
필수 매개변수들을 받는 생성자를 만들어놓고, 선택 매개변수들을 하나씩 추가하면서 메서드를 늘려나가는 방식이다.  
사용하는 클라이언트는 매개변수가 가장 적은 메서드를 택해서 인스턴스를 만들면 된다.  

하지만 매개변수의 개수가 많아지면 코드를 작성하기가 어렵다는 단점이 있다.  
또한 타입이 비슷한 매개변수가 많아진다면 클라이언트가 실수할 확률도 높아지고, 디버깅도 어렵게 된다.  

두 번째 방법은 `자바빈즈(JavaBeans pattern)`이다.  
기본 생성자로 인스턴스를 만들고, 필요한 파라미터를 setter로 하나씩 채워넣는 방식이다.  

앞서 말한 점층적 생성자 패턴에서의 가독성 문제는 해결되었지만, 인스턴스를 만들기 위해서 메서드를 여러 개 호출해야 하고, 완전히 생성되기 전까지 일관성(consistency)이 무너진 상태라는 단점이 있다.  

세 번째는 `빌더 패턴`이다.  
빌더는 생성할 클래스 안에 정적 멤버 클래스로 생성한다.  
필수 매개변수를 빌더의 생성자로 받고, 선택 매개변수들을 빌더의 setter 메서드로 받는다.  
각 setter는 자기자신인 빌더를 반환하기 때문에 연쇄적으로 메서드를 호출할 수 있다.  
이를 **플루언트 API(fluent API)** 혹은 **메서드 연쇄(method chaining)** 라 한다.  

또한 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.  
상위 추상 클래스에서 빌더의 기본 골격만 남겨놓고 하위 구현체들에게 추상 메서드로 열어주면, 구체 클래스들이 이를 받아서 빌더를 구현하는 방식이다.  
또한 각 구현체 빌더에서는 추상 타입 대신 각자의 정확한 구현체 타입으로 반환할 수 있게 된다.  

> 보통은 지양하는 상속 구조에 빌더까지 사용할 일이 있을까 싶긴 하다.  
> 롬복(lombok) 플러그인의 최대 장점은 아무래도 builder 자동 생성이 아닐까 싶다.

---

## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

`싱글턴(singleton)`이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.  
상태가 없거나 유일해야 하는 인스턴스인 경우 유용하게 사용할 수 있지만, mocking을 할 수 없게 되기 때문에 테스트가 어려울 수는 있다.  

싱글턴을 만드는 첫 번째 방법은 다음과 같다.  

```java
public class Example {
    public static final Example INSTANCE = new Example();

    private Example() { ... }
    // ...
}
```

private 생성자는 public static final 필드가 초기화될 때 딱 한 번만 호출된다.  
이 방식의 장점은 해당 클래스가 싱글턴임이 명백하게 드러난다는 것이다.  
하지만 리플렉션 API를 사용하면 클라이언트가 private 생성자에도 접근할 수 있다는 단점이 있다.  

두 번째 방법은 다음과 같다.  

```java
public class Example {
    private static final Example INSTANCE = new Example();

    private Example() { ... }

    public static Example getInstance() { return INSTANCE; }
    // ...
}
```

정적 팩토리 방식의 장점은 다음과 같다.  

- 마음이 바뀌면 API를 변경하지 않고도 싱글턴이 아니게 변경할 수 있다.
- 정적 팩토리를 제네릭 싱글턴 팩토리로 변경하여 타입에 유연하게 대처할 수 있다.
- 정적 팩토리의 메서드 참조를 공급자(supplier)로 사용할 수 있다.
	- 파라미터는 없고 T 객체를 리턴하는 공급자

리플렉션으로 private 생성자에 접근 가능하다는 단점은 여전히 존재한다.  

위 두가지 방법으로 만든 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 선언하는 것만으로는 부족하다.  
이를 위해서는 readResolve() 메서드를 사용해야 하는데, 그러지 않는다면 직렬화된 인스턴스를 역직렬화할 때마다 새로운 인스턴스가 만들어진다.  

```java
private Object readResolve() { // 싱글턴을 보장해주는 readResolve
    return INSTANCE;
}
```

싱글턴을 만드는 마지막 방법은 직렬화나 리플렉션 공격을 완벽히 막아주는 방법이다.  

```java
public enum Example {
    INSTANCE;

    // ...
}
```

**원소가 하나뿐인 열거 타입은 싱글턴을 만드는 가장 좋은 방법**이다.  
단, 만들려는 싱글턴이 상속을 필요로 한다면 사용 불가한 방법이다.  

---
















