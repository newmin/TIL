## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.  
잘 설계된 컴포넌트는 구현과 API를 말끔히 분리하고, 오직 API를 통해서만 다른 컴포넌트와 소통하며 내부 동작 방식에는 전혀 개의치 않는다.  

`캡슐화` 는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 한다.  

- 여러 컴포넌트를 병렬로 개발할 수 있기 때문에 개발 속도를 높일 수 있다.
- 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문에 관리 비용을 낮춘다.
- 컴포넌트가 독립적이어서 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
- 소프트웨어 재사용성을 높인다.
- 개별 컴포넌트의 동작을 검증할 수 있기 때문에 큰 시스템을 제작하는 난이도를 낮춘다.

기본 원칙은, **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**는 점이다.  

멤버를 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자.  
이러면 API가 아닌 내부 구현이 되어 다음 릴리즈와 관계없이 언제든 수정할 수 있다.  
공개 API는 하위 호환을 위해 영원히 관리해줘야만 한다.  
protected도 package-private에 비해 범위가 엄청 넓고, 이 또한 공개 API이기 때문에 영원히 관리해야 한다.  

멤버 접근성을 좁히지 못하게 방해하는 제약이 하나 있는데, 상위 클래스의 메서드를 재정의할 때 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 점이다.  
이는 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해서 사용할 수 있어야 한다는 원칙(LSP, 리스코프 치환 원칙)을 지키기 위해서 필요하다.  

코드를 테스트하려는 목적으로 접근 범위를 넓히려 할 때가 있는데, 적당한 수준까지는 괜찮다.  
public 클래스의 private 멤버를 package-private 까지 풀어주는 것은 허용할 수 있지만, 그 이상은 안 된다.  

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.  
필드가 가변 객체를 참조하거나, final이 아닌 경우 불변식을 보장할 수 없고, 필드가 수정될 때 (락 획득 같은) 다른 작업을 할 수 없게 되므로 Thread-Safe 하지 않게 된다.  

해당 클래스가 표현하는 추상 개념을 완성하는 데 필요한 상수라면 public static final 필드로 공개해도 좋다.  

클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.  
외부에서 해당 내용을 수정할 수 있기 때문이다.  
대신 반환 시 public 불변 리스트로 반환해주거나, 방어적 복사를 활용해 반환해줄 수 있다.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

이따금 다음과 같이 필드만 모아놓는 퇴보한 클래스를 작성하려 할 때가 있다.  

```java
class Point {
    public double x;
    public double y;
}
```

이런 클래스는 데이터 필드에 직접 접근이 가능하니 캡슐화의 이점을 제공하지 못한다.  
그래서 객체지향 프로그래머는 모든 필드를 private으로 바꾸고 public 접근자(getter)를 추가한다.  

public 클래스에서라면 위 private 제어 방식이 확실히 맞다.  
패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.  
public 클래스가 필드를 공개하면 이를 사용하는 클라이언트가 생겨날 것이므로 내부 표현 방식을 마음대로 바꿀 수 없게 된다.  

하지만 **package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.**  
해당 클래스가 표현하고자 하는 추상 개념만 올바르게 표현해주면 된다.

## 아이템 17. 변경 가능성을 최소화하라

불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.  
불변 클래스에 간직된 정보는 객체가 파괴되는 순간까지 절대 달라지지 않는다.  
불변 클래스는 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 안전하다.  

클래스를 불변으로 만드는 규칙은 다음의 다섯 가지이다.  

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 객체의 상태를 변하게 하는 사태를 방지한다.
    - 상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이지만, 다른 방법도 아래에서 살펴보겠다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
    - public final로만 선언해도 불변 객체가 되긴 하지만, 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권장하지 않는다.
- 자신 외에는 내부의 가변 컴포넌트의 접근할 수 없도록 한다.

불변 객체는 근본적으로 **Thread-Safe**하여 따로 동기화할 필요 없다.  
여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.  
그렇기에 불변 객체는 안심하고 공유할 수 있다.  
따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.  
**가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수(public static final)로 제공하는 것**이다.  

불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다.  

불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다는 결론으로 자연스럽게 이어진다.  
그러니 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.  

불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.  

불변 객체는 그 자체로 실패 원자성을 제공한다.  
실패 원자성이란, 메서드에서 예외가 발생한 후에도 그 객체는 여전히 (메서드 호출 전과 똑같은) 유효한 상태여야 한다는 성질이다.  

불변 클래스에도 단점은 있다.  
값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.  
값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다.  

앞서 자신을 상속하지 못하게 하는 방법에 클래스를 final로 만드는 방법이 있다고 했는데, 그것 말고도 더 유연한 방법이 있다.  
모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다.  
패키지 바깥의 클라이언트에서 바라본 해당 객체는 사실상 final이다.  
public이나 protected 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는 게 불가능하기 때문이다.  

모든 클래스를 불변으로 만들 수는 없다.  
불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.  
다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.  

**생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야** 한다.  
확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
