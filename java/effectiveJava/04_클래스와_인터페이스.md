## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.  
잘 설계된 컴포넌트는 구현과 API를 말끔히 분리하고, 오직 API를 통해서만 다른 컴포넌트와 소통하며 내부 동작 방식에는 전혀 개의치 않는다.  

`캡슐화` 는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 한다.  

- 여러 컴포넌트를 병렬로 개발할 수 있기 때문에 개발 속도를 높일 수 있다.
- 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문에 관리 비용을 낮춘다.
- 컴포넌트가 독립적이어서 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
- 소프트웨어 재사용성을 높인다.
- 개별 컴포넌트의 동작을 검증할 수 있기 때문에 큰 시스템을 제작하는 난이도를 낮춘다.

기본 원칙은, **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**는 점이다.  

멤버를 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자.  
이러면 API가 아닌 내부 구현이 되어 다음 릴리즈와 관계없이 언제든 수정할 수 있다.  
공개 API는 하위 호환을 위해 영원히 관리해줘야만 한다.  
protected도 package-private에 비해 범위가 엄청 넓고, 이 또한 공개 API이기 때문에 영원히 관리해야 한다.  

멤버 접근성을 좁히지 못하게 방해하는 제약이 하나 있는데, 상위 클래스의 메서드를 재정의할 때 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 점이다.  
이는 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해서 사용할 수 있어야 한다는 원칙(LSP, 리스코프 치환 원칙)을 지키기 위해서 필요하다.  

코드를 테스트하려는 목적으로 접근 범위를 넓히려 할 때가 있는데, 적당한 수준까지는 괜찮다.  
public 클래스의 private 멤버를 package-private 까지 풀어주는 것은 허용할 수 있지만, 그 이상은 안 된다.  

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.  
필드가 가변 객체를 참조하거나, final이 아닌 경우 불변식을 보장할 수 없고, 필드가 수정될 때 (락 획득 같은) 다른 작업을 할 수 없게 되므로 Thread-Safe 하지 않게 된다.  

해당 클래스가 표현하는 추상 개념을 완성하는 데 필요한 상수라면 public static final 필드로 공개해도 좋다.  

클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.  
외부에서 해당 내용을 수정할 수 있기 때문이다.  
대신 반환 시 public 불변 리스트로 반환해주거나, 방어적 복사를 활용해 반환해줄 수 있다.  

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

이따금 다음과 같이 필드만 모아놓는 퇴보한 클래스를 작성하려 할 때가 있다.  

```java
class Point {
    public double x;
    public double y;
}
```

이런 클래스는 데이터 필드에 직접 접근이 가능하니 캡슐화의 이점을 제공하지 못한다.  
그래서 객체지향 프로그래머는 모든 필드를 private으로 바꾸고 public 접근자(getter)를 추가한다.  

public 클래스에서라면 위 private 제어 방식이 확실히 맞다.  
패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.  
public 클래스가 필드를 공개하면 이를 사용하는 클라이언트가 생겨날 것이므로 내부 표현 방식을 마음대로 바꿀 수 없게 된다.  

하지만 **package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.**  
해당 클래스가 표현하고자 하는 추상 개념만 올바르게 표현해주면 된다.  

## 아이템 17. 변경 가능성을 최소화하라

불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.  
불변 클래스에 간직된 정보는 객체가 파괴되는 순간까지 절대 달라지지 않는다.  
불변 클래스는 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 안전하다.  

클래스를 불변으로 만드는 규칙은 다음의 다섯 가지이다.  

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 객체의 상태를 변하게 하는 사태를 방지한다.
    - 상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이지만, 다른 방법도 아래에서 살펴보겠다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
    - public final로만 선언해도 불변 객체가 되긴 하지만, 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권장하지 않는다.
- 자신 외에는 내부의 가변 컴포넌트의 접근할 수 없도록 한다.

불변 객체는 근본적으로 **Thread-Safe**하여 따로 동기화할 필요 없다.  
여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.  
그렇기에 불변 객체는 안심하고 공유할 수 있다.  
따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.  
**가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수(public static final)로 제공하는 것**이다.  

불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다.  

불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다는 결론으로 자연스럽게 이어진다.  
그러니 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.  

불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.  

불변 객체는 그 자체로 실패 원자성을 제공한다.  
실패 원자성이란, 메서드에서 예외가 발생한 후에도 그 객체는 여전히 (메서드 호출 전과 똑같은) 유효한 상태여야 한다는 성질이다.  

불변 클래스에도 단점은 있다.  
값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.  
값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다.  

앞서 자신을 상속하지 못하게 하는 방법에 클래스를 final로 만드는 방법이 있다고 했는데, 그것 말고도 더 유연한 방법이 있다.  
모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다.  
패키지 바깥의 클라이언트에서 바라본 해당 객체는 사실상 final이다.  
public이나 protected 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는 게 불가능하기 때문이다.  

모든 클래스를 불변으로 만들 수는 없다.  
불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.  
다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.  

**생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야** 한다.  
확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.  

## 아이템 18. 상속보다는 컴포지션을 사용하라

상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다.  
같은 프로그래머가 통제하는 패키지 내부라면 상속도 안전한 방법이고, 확장할 목적으로 설계되었으며 문서화도 잘 된 클래스라면 역시 안전한 방법이다.  
하지만 일반적인 구체 클래스를 패키지 경계를 넘어, 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.  
**메서드 호출과 달리 상속은 캡슐화를 깨뜨리기 때문**이다.  
다르게 말하면, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.  

예를 들어, HashSet의 add(), addAll() 메서드를 상속하여 재정의하는 경우, 상위 클래스인 HashSet의 addAll() 메서드에서 내부적으로 add()를 사용하기 때문에 재정의한 메서드에서 문제가 생길 수 있다.  
이처럼 자신의 다른 부분을 사용하는 `자기 사용(self-use)` 여부는 해당 클래스의 내부 구현 방식에 해당하며, 다음 릴리스에서도 유지될지는 알 수 없다.  

하위 클래스가 깨지기 쉬운 또다른 이유는, 다음 릴리스에서 상위 클래스에 새로운 메서드가 추가되는 경우이다.  
다른 메서드가 공통의 상위 클래스 필드를 건드린다면, 하위 클래스에서는 예상치 못한 문제들이 생길 수 있다.  

위의 문제들 모두 메서드 재정의가 원인이었다.  
하지만 메서드 재정의를 하지 않고 새로운 메서드만 추가하는 형태로 확장한다 하더라도, 다음 릴리스에 추가된 상위 클래스의 새 메서드가 우리가 만든 메서드와 충돌할 가능성도 다분하다.  
자칫하면 시그니처가 같을 경우 컴파일에서부터 깨질 염려도 있다.  

위의 문제를 모두 피해가는 묘안은 바로 `컴포지션`이다.  
기존 클래스를 확장하는 대신, 새로운 인스턴스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다.  
새 클래스의 인스턴스들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.  
이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 한다.  

상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다.  
클래스 B가 클래스 A와 `is-a` 관계일 때만 클래스 A를 상속해야 한다.  

컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.  
그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다.  
더 심각한 문제는 클라이언트가 노출된 내부에 직접 접근할 수 있다는 점이다.  

상속은 상위 클래스 API의 '결함'까지도 그대로 승계하기 때문에, 상속을 사용하기 전 자문해보는 것이 좋다.  

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.  
상속용 클래스는 재정의할 수 있는 메서드들을 `내부적으로 어떻게 이용하는지(자기사용)` 문서로 남겨야 한다.  

API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.  
메서드 주석에 `@implSpec` 태그를 붙여주면 자바독 도구가 생성해준다.  

문서만이 상속 설계의 전부는 아니다.  
효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.  

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 `유일` 하다.  
널리 쓰일 클래스를 상속용으로 설계한다면 여러분이 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다.  
그러니 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.  

제약은 또 있다.  
**상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.**  
상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 실행되기 때문이다.  

Cloneable과 Serializable 인터페이스 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.  
clone과 readObject 메서드는 생성자와 비슷한 효과를 내기 때문에(새로운 객체를 만든다) 마찬가지로 재정의 가능 메서드를 호출해서는 안된다.  

가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 다음 두 가지 방법으로 상속을 금지하는 것이다.  

- 클래스를 final로 선언한다.
- 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어준다.

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다.  
자바 8부터 인터페이스도 default 메서드를 제공할 수 있게 되었다.  
둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.  
자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 된다.  
반면 인터페이스의 규약을 잘 지킨 클래스라면 어떤 클래스를 상속했든 같은 타입으로 취급된다.  

**인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.**  
타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에서는 계층을 엄격히 구분하기 어려운 개념도 있다.  
여러 타입을 한번에 계승하여 구현하거나, 제 3의 인터페이스를 만들 수도 있다.  

한편, 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.  
이렇게 해두면 단순히 골격 구현을 확장하는 것만으로 이 인터페이슬르 구현하는 데 필요한 일이 대부분 완료된다.  
바로 템플릿 메서드 패턴이다.  

## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다.  
자바 7까지의 세상에서는 모든 클래스가 "현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다"고 가정하고 작성됐으니 말이다.  
자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다.  
하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.  

디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.  
새로운 인터페이스를 만든다면 디폴트 메서드는 표준 구현을 제공하는 아주 좋은 수단이지만, 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.  
디폴트 메서드라는 도구가 있더라도 인터페이스를 설계할 때는 세심한 주의를 기울여야 한다.  
인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안 된다.
