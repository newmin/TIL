## 제네릭 용어

- 매개변수화 타입(parameterized type)
    - `List<String>`
- 실제 타입 매개변수(actual type parameter)
    - `String`
- 제네릭 타입(generic type)
    - `List<E>`
- 정규 타입 매개변수(formal type parameter)
    - `E`
- 비한정적 와일드카드 타입(unbounded wildcard type)
    - `List<?>`
- 로 타입(raw type)
    - `List`
- 한정적 타입 매개변수(bounded type parameter)
    - `<E extends Number>`
- 재귀적 타입 한정(recursive type bound)
    - `<T extends Comparable<T>>`
- 한정적 와일드카드 타입(bounded wildcard type)
    - `List<? extends Number>`
- 제네릭 메서드(generic method)
    - `static <E> List<E> asList(E[] a)`
- 타입 토큰(type token)
    - `String.class`

## 아이템 26. 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라고 한다. (`List<E>`)  
이 둘을 통틀어 제네릭 타입이라고 한다.  
각각의 제네릭 타입은 매개변수화 타입을 정의한다. (`List<String>` 에서 `String`)  
제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 함께 정의된다. (`List<E>` 의 로 타입은 `List`)  

로 타입은 절대로 써서는 안 된다.  
이는 컴파일 타임에 오류를 찾을 수 없게 하며, 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 한다.  
로 타입은 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책일 뿐이다.  

만약 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 비한정적 와일드카드 타입(`?`, 물음표)을 사용하자.  

예외는 몇 가지 있다.  

- class 리터럴에는 로 타입을 써야 한다.
    - 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. (`List<String>.class` , `List<?>.class` 허용 안함)
- 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
    - 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다.

## 아이템 27. 비검사 경고를 제거하라

제네릭을 사용하고 나오는 비검사 경고들은 최대한 제거하자.  

만약 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면, `@SuppressWarnings("unchecked")` 어노테이션으로 경고를 숨기자.  
다만 해당 어노테이션은 가능한 한 좁은 범위에 적용하고, 적용한 이유를 주석으로 남겨놓자.  

## 아이템 28. 배열보다는 리스트를 사용하라

배열과 제네릭 타입에는 중요한 차이가 두 가지 있다.  

첫 번째, 배열은 공변(covariant)이고 제네릭은 불공변(invariant)이다.  
Sub가 Super의 하위 타입이라면 배열 `Sub[]`는 배열 `Super[]`의 하위 타입이 되지만, `List<Sub>`는 `List<Super>` 의 하위 타입이 아니다.  

```java
Object[] objectArray = new Long[1];
objectArray[0] = ""; // ArrayStoreException

List<Object> objectList = new ArrayList<Long>(); // 컴파일 타임에 실패
objectList.add(""); // 불가능
```

위 예제에서 볼 수 있듯이 배열은 공변이기 때문에 런타임 시점에 가서야 타입이 잘못되었다는 것을 알지만, 제네릭은 컴파일 타임에서부터 실패하기 때문에 더 유리하다.  

두 번째, 배열은 실체화(reify)된다.  
배열은 런타임에도 자신이 담기로 한 타입을 인지하고 확인하는 반면, 제네릭은 런타임에 타입 정보가 소거(erasure)된다.  

위의 차이로 인해 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.  
(`new List<E>[]`, `new List<String>[]`, `new E[]` 와 같은 형식 불가능)  

`E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다.  
실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.  

## 아이템 29. 이왕이면 제네릭 타입으로 만들라

일반 클래스를 제네릭 클래스로 만들려면 클래스 선언에 타입 매개변수를 추가하면 된다.  
이때 타입 이름으로는 보통 `E` 를 사용한다.  

기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.  
기존 클라이언트에는 아무 영향을 주지 않으면서 새로운 사용자를 훨씬 편하게 해주는 길이다.  

## 아이템 30. 이왕이면 제네릭 메서드로 만들라

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}
```

(타입 매개변수들을 선언하는) 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 온다.  

상대적으로 드물지만, 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있다.  
바로 `재귀적 타입 한정(recursive type bound)` 라는 개념이다.  
재귀적 타입 한정은 주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰인다.  

```java
public static <E extends Comparable<E>> E max(Collection<E> c);
```

타입 한정인 `<E extends Comparable<E>>` 는 "모든 타입 E는 자신과 비교할 수 있다"라고 읽을 수 있다.  

## 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 호출 시에 가변인수를 담기 위한 배열이 자동으로 만들어진다.  
그런데 내부로 감췄어야 할 배열을 외부로 노출하고 말았기 때문에, varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.  
매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생하는데, 이런 상황에서는 제네릭 타입 시스템이 약속한 타입 안정성의 근간이 흔들려버린다.  

제네릭 배열을 프로그래머가 직접 생성하는 건 허용하지 않으면서 제네릭 varargs 매개변수를 받는 메서드를 선언할 수 있게 한 이유는 무엇일까?  
바로 실무에서 매우 유용하게 사용할 수 있기 때문이다.  
그래서 언어 설계자는 이 모순을 수용하기로 했다.  
실제로 `Arrays.asList(T... a)`, `Collections.addAll(Collection<? super T> c, T... elements)`, `EnumSet.of(E first, E... rest)` 같은 것들이 있다.  
이들은 위에서 말한 상황과 달리 타입 안전하다.  

자바 7에서는 `@SafeVarargs` 애너테이션이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측의 경고를 숨길 수 있게 되었다.  
`@SafeVarargs` 애너테이션은 다르게 말하면 메서드 작성자가 해당 메서드의 타입 안정성을 보장한다는 의미가 된다.  
즉, 메서드 작성자는 메서드가 안전한게 확실하지 않다면 `@SafeVarargs` 애너테이션을 달아서는 안 된다.  

언제 안전한가?  
제네릭 가변인수 메서드 호출 시 제네릭 배열이 만들어지는데, 메서드에서 이 배열에 아무것도 저장하지 않고, 해당 배열의 참조가 밖으로 노출되지 않는다면 타입 안전하다.  
특히 아무것도 안하더라도 외부로 해당 배열을 반환해버리거나 하는 경우, 힙 오염이 호출한 쪽의 콜스택으로까지 전이될 수 있기 때문에 주의해야 한다.  

정리하자면, 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 `@SafeVarargs` 를 달아야 한다.  
달리 말하면 안전하지 않은 varargs 메서드는 절대 작성해서는 안 된다는 뜻이다.  
다음 사항을 반드시 지켜야 한다.  

- varargs 배열에 아무것도 저장하지 않는다.
- 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다.
    - `@SafeVarargs` 애너테이션은 재정의할 수 없는 메서드에만 달아야 한다. 재정의한 메서드도 안전할지는 보장할 수 없기 때문이다.

varargs 매개변수 대신 List로 구현하는 방법을 사용하면 성능은 살짝 떨어질 수 있지만 더 깔끔할 수 있으니 참고하자.
