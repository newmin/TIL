## 아이템 34. int 상수 대신 열거 타입을 사용하라

정수 열거 패턴이나 문자열 열거 패턴에는 단점이 많다.  
타입 안전을 보장할 방법이 없으며 표현력도 좋지 않다.  
정수 열거 패턴은 평범한 상수를 나열한 것이라 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨지고, 상수 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야 한다.  

Java에서는 열거 패턴의 단점을 해결하면서 동시에 여러 장점을 주는 대안을 제시하는데, 바로 열거 타입(Enum Type)이다.  

열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.  
열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로, 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없어 이 인스턴스들은 딱 하나씩만 존재하게 된다.  
즉, 싱글턴을 확장해 더 일반화한 형태라고 볼 수 있다.  

열거 타입에는 다음과 같은 장점들이 있다.  

- 컴파일 타입 안정성을 제공한다.
- 각자의 이름 공간이 있어서 이름이 같은 상수도 공존할 수 있다.
- 임의의 메서드나 필드를 추가할 수 있고, 임의의 인터페이스를 구현하게 할 수도 있다.
    - 그저 상수 모음이지만, 실제로는 클래스이기 때문에 고차원의 추상 개념 하나를 완벽히 표현해낼 수도 있는 것이다.

열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.  

더 나아가보면, 상수마다 동작이 달라져야 하는 상황도 있을 수 있다.  
이때는 열거 타입에 추상 메서드를 선언하고, 각 상수별 클래스 body에서 재정의하는 방법을 사용할 수도 있다.  
이를 상수별 메서드 구현이라 한다.  

단, 상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점도 있는데, 이는 내부 Enum을 별도로 만들어, 상위 Enum에서 내부 Enum을 각자 상황에 맞게 참조하도록 하면 조금 복잡할지언정 안전하고 유연하게 설계할 수 있다.  

결론은, 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자는 것이다.  
열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.  
열거 타입은 나중에 사웃가 추가돼도 바이너리 수준에서 호환되도록 설계되었기 때문이다.  

## 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라

열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다.  
그리고 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal()이라는 메서드를 제공한다.  

```java
public enum Ensenble {

    SOLO, DUET, TRIO;

    public int numberOfMusicians() {
        return ordinal() + 1;
    }

}
```

하지만 위와 같이 ordinal()을 사용한 메서드는, Enum의 순서를 바꾸는 순간 오동작하게 된다.  

즉, 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장해야 한다.  

## 아이템 36. 비트 필드 대신 EnumSet을 사용하라

열거한 값들이 단독 형태가 아니라 집합 형태로 사용될 경우, 예전에는 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용했다.  

```java
public class Text {

    public static final int STYLE_BOLD = 1 << 0; // 1
    public static final int STYLE_ITALIC = 1 << 1; // 2
    public static final int STYLE_UNDERLINE = 1 << 2; // 4
    public static final int STYLE_STRIKETHROUGH = 1 << 3; // 8

    // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값이다.
    public void applyStyles(int styles) { ... }

}
```

```java
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```

비트 필드는 다음과 같은 단점이 있다.  

- 정수 열거 상수의 단점을 그대로 가진다.
- 비트 필드 값이 그대로 출력되면 단순한 정수 열거 상수보다 해석하기가 훨씬 어렵다.
- 비트 필드 하나에 녹아 있는 모든 원소를 순회하기도 까다롭다.
- 최대 몇 비트가 필요한지를 미리 예측하여 적절한 타입(int나 long 등)을 선택해야 한다.

이러한 비트 필드 대신 `EnumSet` 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.  
Set 인터페이스를 구현하면서 타입 안전하다.  

```java
public class Text {

    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }

    public void applyStyles(Set<Style> styles) { ... }

}
```

## 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라

가끔 배열이나 리스트에서 원소를 꺼낼 때 ordinal 메서드로 인덱스를 얻는 코드가 있다.  
이는 다음과 같은 문제가 있다.  

- 배열은 제네릭과 호환되지 않으니 비검사 형변환을 수행해야 하고, 깔끔히 컴파일되지 않을 것이다.
- 배열은 각 인덱스의 의미를 모르니 출력 결과에 직접 레이블을 달아야 한다.
- 정확한 정숫값을 사용한다는 것을 사용자가 직접 보증해야 한다.

실제로 배열은 열거 타입 상수를 값으로 매핑하는 역할을 하니, 더 확실하고 좋은 해결책이 있다.  
열거 타입을 키로 사용하도록 설계한 아주 빠른 Map 구현체인 EnumMap이 바로 그것이다.  

EnumMap의 성능이 ordinal을 쓴 배열에 비견되는 이유는 그 내부에서 배열을 사용하기 때문이다.  
배열의 인덱스를 얻을 일이 필요하다면 반드시 EnumMap을 고려하자.  

## 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

열거 타입은 타입 안전 열거 패턴(typesafe enum pattern, 일반 클래스에 다수의 인스턴스 상수를 선언하는 방법)보다 우수하다.  
한 가지 예외가 있는데, 타입 안전 열거 패턴은 확장할 수 있으나 열거 타입은 그럴 수 없다는 점이다.  
타입 안전 열거 패턴은 일반 클래스이기 때문에 확장하면서 기존 값에 새로운 값을 더 추가할 수 있는 반면, 열거 타입은 그럴 수 없다.  

다행히 다른 방법이 있는데, 열거 타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이용하는 것이다.  
인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게 한다.  
이때 열거 타입은 해당 인터페이스의 표준 구현체 역할을 한다.  

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    // ...
}

public enum ExtendedOperation implements Operation {
    EXP("^") {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    // ...
}
```

사용하는 쪽에서는 Operation 인터페이스를 사용하도록만 되어있다면 어디든 쓸 수 있다.  

한 가지 사소한 문제가 있다면 열거 타입끼리 구현을 상속할 수 없다는 점이다.  
공통으로 연산 기호를 찾는다던지 하는 로직은 별도의 도우미 클래스나 정적 도우미 메서드로 분리하는 방식으로 가져갈 수도 있을 것이다.
